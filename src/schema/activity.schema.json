{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {
        "AbstractCursor<any,any>": {
            "properties": {
                "closed": {
                    "type": "boolean"
                },
                "id": {
                    "$ref": "#/definitions/Long"
                },
                "killed": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                }
            },
            "type": "object"
        },
        "Admin": {
            "description": "The **Admin** class is an internal class that allows convenient access to\nthe admin functionality and commands for MongoDB.\n\n**ADMIN Cannot directly be instantiated**",
            "type": "object"
        },
        "Aggregate<any>": {
            "properties": {
                "catch": {
                    "description": "Executes the query returning a `Promise` which will be\nresolved with either the doc(s) or rejected with the error.\nLike [`.then()`](#query_Query-then), but only takes a rejection handler.",
                    "type": "object"
                },
                "options": {
                    "$ref": "#/definitions/AggregateOptions"
                },
                "then": {
                    "description": "Provides promise for aggregate.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "AggregateOptions": {
            "additionalProperties": {},
            "properties": {
                "allowDiskUse": {
                    "description": "allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>).",
                    "type": "boolean"
                },
                "authdb": {
                    "type": "string"
                },
                "batchSize": {
                    "description": "The number of documents to return per batch. See [aggregation documentation](https://docs.mongodb.com/manual/reference/command/aggregate).",
                    "type": "number"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "bypassDocumentValidation": {
                    "description": "Allow driver to bypass schema validation in MongoDB 3.2 or higher.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Specify collation."
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "cursor": {
                    "$ref": "#/definitions/Document",
                    "description": "Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor."
                },
                "dbName": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Add an index selection hint to an aggregation command"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "let": {
                    "$ref": "#/definitions/Document",
                    "description": "Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0)."
                },
                "maxAwaitTimeMS": {
                    "description": "The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query.",
                    "type": "number"
                },
                "maxTimeMS": {
                    "description": "specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.",
                    "type": "number"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "out": {
                    "type": "string"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest)."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ClientSession"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "AggregationCursor<any>": {
            "description": "The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\nallowing for iteration over the results returned from the underlying query. It supports\none by one document iteration, conversion to an array or can be iterated as a Node 4.X\nor higher stream",
            "properties": {
                "closed": {
                    "type": "boolean"
                },
                "id": {
                    "$ref": "#/definitions/Long"
                },
                "killed": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "pipeline": {
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                }
            },
            "type": "object"
        },
        "AnyObject": {
            "additionalProperties": {},
            "type": "object"
        },
        "ArrayBuffer": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "byteLength": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ArrayBufferLike": {
            "anyOf": [
                {
                    "$ref": "#/definitions/ArrayBuffer"
                },
                {
                    "$ref": "#/definitions/SharedArrayBuffer"
                }
            ]
        },
        "ArrayConstructor": {
            "properties": {
                "__@species@1110": {
                    "$ref": "#/definitions/ArrayConstructor"
                },
                "prototype": {
                    "items": {},
                    "type": "array"
                }
            },
            "type": "object"
        },
        "AsyncValidateFn<Schema.Types.Mixed>": {
            "type": "object"
        },
        "AsyncValidateFn<any>": {
            "type": "object"
        },
        "AuthMechanism": {
            "enum": [
                "DEFAULT",
                "GSSAPI",
                "MONGODB-AWS",
                "MONGODB-CR",
                "MONGODB-X509",
                "PLAIN",
                "SCRAM-SHA-1",
                "SCRAM-SHA-256"
            ],
            "type": "string"
        },
        "AuthMechanismProperties": {
            "properties": {
                "AWS_SESSION_TOKEN": {
                    "type": "string"
                },
                "CANONICALIZE_HOST_NAME": {
                    "enum": [
                        false,
                        "forward",
                        "forwardAndReverse",
                        "none",
                        true
                    ]
                },
                "SERVICE_HOST": {
                    "type": "string"
                },
                "SERVICE_NAME": {
                    "type": "string"
                },
                "SERVICE_REALM": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "AutoEncrypter": {
            "properties": {
                "cryptSharedLibVersionInfo": {
                    "anyOf": [
                        {
                            "properties": {
                                "version": {
                                    "additionalProperties": false,
                                    "properties": {},
                                    "type": "number"
                                },
                                "versionStr": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "null"
                        }
                    ]
                }
            },
            "type": "object"
        },
        "AutoEncryptionOptions": {
            "properties": {
                "bypassAutoEncryption": {
                    "description": "Allows the user to bypass auto encryption, maintaining implicit decryption",
                    "type": "boolean"
                },
                "bypassQueryAnalysis": {
                    "type": "boolean"
                },
                "encryptedFieldsMap": {
                    "$ref": "#/definitions/Document"
                },
                "extraOptions": {
                    "properties": {
                        "cryptSharedLibPath": {
                            "description": "Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\n\nThis needs to be the path to the file itself, not a directory.\nIt can be an absolute or relative path. If the path is relative and\nits first component is `$ORIGIN`, it will be replaced by the directory\ncontaining the mongodb-client-encryption native addon file. Otherwise,\nthe path will be interpreted relative to the current working directory.\n\nCurrently, loading different MongoDB Crypt shared library files from different\nMongoClients in the same process is not supported.\n\nIf this option is provided and no MongoDB Crypt shared library could be loaded\nfrom the specified location, creating the MongoClient will fail.\n\nIf this option is not provided and `cryptSharedLibRequired` is not specified,\nthe AutoEncrypter will attempt to spawn and/or use mongocryptd according\nto the mongocryptd-specific `extraOptions` options.\n\nSpecifying a path prevents mongocryptd from being used as a fallback.\n\nRequires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.",
                            "type": "string"
                        },
                        "cryptSharedLibRequired": {
                            "description": "If specified, never use mongocryptd and instead fail when the MongoDB Crypt\nshared library could not be loaded.\n\nThis is always true when `cryptSharedLibPath` is specified.\n\nRequires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.",
                            "type": "boolean"
                        },
                        "mongocryptdBypassSpawn": {
                            "description": "If true, autoEncryption will not attempt to spawn a mongocryptd before connecting",
                            "type": "boolean"
                        },
                        "mongocryptdSpawnArgs": {
                            "description": "Command line arguments to use when auto-spawning a mongocryptd",
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "mongocryptdSpawnPath": {
                            "description": "The path to the mongocryptd executable on the system",
                            "type": "string"
                        },
                        "mongocryptdURI": {
                            "description": "A local process the driver communicates with to determine how to encrypt values in a command.\nDefaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "keyVaultClient": {
                    "$ref": "#/definitions/MongoClient",
                    "description": "A `MongoClient` used to fetch keys from a key vault"
                },
                "keyVaultNamespace": {
                    "description": "The namespace where keys are stored in the key vault",
                    "type": "string"
                },
                "kmsProviders": {
                    "description": "Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.",
                    "properties": {
                        "aws": {
                            "description": "Configuration options for using 'aws' as your KMS provider",
                            "properties": {
                                "accessKeyId": {
                                    "description": "The access key used for the AWS KMS provider",
                                    "type": "string"
                                },
                                "secretAccessKey": {
                                    "description": "The secret access key used for the AWS KMS provider",
                                    "type": "string"
                                },
                                "sessionToken": {
                                    "description": "An optional AWS session token that will be used as the\nX-Amz-Security-Token header for AWS requests.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "azure": {
                            "description": "Configuration options for using 'azure' as your KMS provider",
                            "properties": {
                                "clientId": {
                                    "description": "The client ID to authenticate a registered application",
                                    "type": "string"
                                },
                                "clientSecret": {
                                    "description": "The client secret to authenticate a registered application",
                                    "type": "string"
                                },
                                "identityPlatformEndpoint": {
                                    "description": "If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\nThis is optional, and only needed if customer is using a non-commercial Azure instance\n(e.g. a government or China account, which use different URLs).\nDefaults to \"login.microsoftonline.com\"",
                                    "type": "string"
                                },
                                "tenantId": {
                                    "description": "The tenant ID identifies the organization for the account",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "gcp": {
                            "description": "Configuration options for using 'gcp' as your KMS provider",
                            "properties": {
                                "email": {
                                    "description": "The service account email to authenticate",
                                    "type": "string"
                                },
                                "endpoint": {
                                    "description": "If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\nDefaults to \"oauth2.googleapis.com\"",
                                    "type": "string"
                                },
                                "privateKey": {
                                    "anyOf": [
                                        {
                                            "additionalProperties": false,
                                            "patternProperties": {
                                                "^[0-9]+$": {
                                                    "type": "number"
                                                }
                                            },
                                            "properties": {
                                                "BYTES_PER_ELEMENT": {
                                                    "type": "number"
                                                },
                                                "__@toStringTag@1754": {
                                                    "const": "Uint8Array",
                                                    "type": "string"
                                                },
                                                "buffer": {
                                                    "$ref": "#/definitions/ArrayBufferLike"
                                                },
                                                "byteLength": {
                                                    "type": "number"
                                                },
                                                "byteOffset": {
                                                    "type": "number"
                                                },
                                                "length": {
                                                    "type": "number"
                                                }
                                            },
                                            "type": "object"
                                        },
                                        {
                                            "type": "string"
                                        }
                                    ],
                                    "description": "A PKCS#8 encrypted key. This can either be a base64 string or a binary representation"
                                }
                            },
                            "type": "object"
                        },
                        "kmip": {
                            "description": "Configuration options for using 'kmip' as your KMS provider",
                            "properties": {
                                "endpoint": {
                                    "description": "The output endpoint string.\nThe endpoint consists of a hostname and port separated by a colon.\nE.g. \"example.com:123\". A port is always present.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "local": {
                            "description": "Configuration options for using 'local' as your KMS provider",
                            "properties": {
                                "key": {
                                    "anyOf": [
                                        {
                                            "additionalProperties": false,
                                            "patternProperties": {
                                                "^[0-9]+$": {
                                                    "type": "number"
                                                }
                                            },
                                            "properties": {
                                                "BYTES_PER_ELEMENT": {
                                                    "type": "number"
                                                },
                                                "__@toStringTag@1754": {
                                                    "const": "Uint8Array",
                                                    "type": "string"
                                                },
                                                "buffer": {
                                                    "$ref": "#/definitions/ArrayBufferLike"
                                                },
                                                "byteLength": {
                                                    "type": "number"
                                                },
                                                "byteOffset": {
                                                    "type": "number"
                                                },
                                                "length": {
                                                    "type": "number"
                                                }
                                            },
                                            "type": "object"
                                        },
                                        {
                                            "type": "string"
                                        }
                                    ],
                                    "description": "The master key used to encrypt/decrypt data keys.\nA 96-byte long Buffer or base64 encoded string."
                                }
                            },
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "options": {
                    "properties": {
                        "logger": {
                            "description": "An optional hook to catch logging messages from the underlying encryption engine",
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "proxyOptions": {
                    "$ref": "#/definitions/ProxyOptions"
                },
                "schemaMap": {
                    "$ref": "#/definitions/Document",
                    "description": "A map of namespaces to a local JSON schema for encryption\n\n**NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\nIt protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\nSchemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\nOther validation rules in the JSON schema will not be enforced by the driver and will result in an error."
                },
                "tlsOptions": {
                    "description": "The TLS options to use connecting to the KMS provider",
                    "properties": {
                        "aws": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "azure": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "gcp": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "kmip": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "local": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "AutoEncryptionTlsOptions": {
            "properties": {
                "tlsCAFile": {
                    "description": "Specifies the location of a local .pem file that contains the\nroot certificate chain from the Certificate Authority.\nThis file is used to validate the certificate presented by the\nKMS provider.",
                    "type": "string"
                },
                "tlsCertificateKeyFile": {
                    "description": "Specifies the location of a local .pem file that contains\neither the client's TLS/SSL certificate and key or only the\nclient's TLS/SSL key when tlsCertificateFile is used to\nprovide the certificate.",
                    "type": "string"
                },
                "tlsCertificateKeyFilePassword": {
                    "description": "Specifies the password to de-crypt the tlsCertificateKeyFile.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BSONRegExp": {
            "description": "A class representation of the BSON RegExp type.",
            "properties": {
                "_bsontype": {
                    "const": "BSONRegExp",
                    "type": "string"
                },
                "options": {
                    "type": "string"
                },
                "pattern": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BSONSerializeOptions": {
            "description": "BSON Serialization options.",
            "properties": {
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "BSONSymbol": {
            "description": "A class representation of the BSON Symbol type.",
            "properties": {
                "_bsontype": {
                    "const": "Symbol",
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Batch<Document>": {
            "description": "Keeps the state of a unordered batch so we can rewrite the results\ncorrectly after command execution",
            "properties": {
                "batchType": {
                    "$ref": "#/definitions/BatchType"
                },
                "currentIndex": {
                    "type": "number"
                },
                "operations": {
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "originalIndexes": {
                    "items": {
                        "type": "number"
                    },
                    "type": "array"
                },
                "originalZeroIndex": {
                    "type": "number"
                },
                "size": {
                    "type": "number"
                },
                "sizeBytes": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Batch<any>": {
            "description": "Keeps the state of a unordered batch so we can rewrite the results\ncorrectly after command execution",
            "properties": {
                "batchType": {
                    "$ref": "#/definitions/BatchType"
                },
                "currentIndex": {
                    "type": "number"
                },
                "operations": {
                    "items": {},
                    "type": "array"
                },
                "originalIndexes": {
                    "items": {
                        "type": "number"
                    },
                    "type": "array"
                },
                "originalZeroIndex": {
                    "type": "number"
                },
                "size": {
                    "type": "number"
                },
                "sizeBytes": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "BatchType": {
            "enum": [
                1,
                2,
                3
            ],
            "type": "number"
        },
        "Binary": {
            "description": "A class representation of the BSON Binary type.",
            "properties": {
                "_bsontype": {
                    "const": "Binary",
                    "type": "string"
                },
                "buffer": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "position": {
                    "type": "number"
                },
                "sub_type": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Boolean": {
            "type": "object"
        },
        "BooleanConstructor": {
            "properties": {
                "prototype": {
                    "$ref": "#/definitions/Boolean"
                }
            },
            "type": "object"
        },
        "BulkOperationBase": {
            "oneOf": [
                {
                    "$ref": "#/definitions/OrderedBulkOperation"
                },
                {
                    "$ref": "#/definitions/UnorderedBulkOperation"
                }
            ]
        },
        "BulkResult": {
            "properties": {
                "insertedIds": {
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "nInserted": {
                    "type": "number"
                },
                "nMatched": {
                    "type": "number"
                },
                "nModified": {
                    "type": "number"
                },
                "nRemoved": {
                    "type": "number"
                },
                "nUpserted": {
                    "type": "number"
                },
                "ok": {
                    "type": "number"
                },
                "opTime": {
                    "$ref": "#/definitions/Document"
                },
                "upserted": {
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "writeConcernErrors": {
                    "items": {
                        "$ref": "#/definitions/WriteConcernError"
                    },
                    "type": "array"
                },
                "writeErrors": {
                    "items": {
                        "$ref": "#/definitions/WriteError"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "BulkWriteOperationError": {
            "properties": {
                "code": {
                    "type": "number"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document"
                },
                "errmsg": {
                    "type": "string"
                },
                "index": {
                    "type": "number"
                },
                "op": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "$ref": "#/definitions/DeleteStatement"
                        },
                        {
                            "$ref": "#/definitions/UpdateStatement"
                        }
                    ]
                }
            },
            "type": "object"
        },
        "BulkWriteResult": {
            "properties": {
                "deletedCount": {
                    "description": "Number of documents deleted.",
                    "type": "number"
                },
                "insertedCount": {
                    "description": "Number of documents inserted.",
                    "type": "number"
                },
                "insertedIds": {
                    "additionalProperties": false,
                    "description": "Inserted document generated Id's, hash key is the index of the originating operation",
                    "patternProperties": {
                        "^[0-9]+$": {}
                    },
                    "type": "object"
                },
                "matchedCount": {
                    "description": "Number of documents matched for update.",
                    "type": "number"
                },
                "modifiedCount": {
                    "description": "Number of documents modified.",
                    "type": "number"
                },
                "nInserted": {
                    "description": "The number of inserted documents",
                    "type": "number"
                },
                "nMatched": {
                    "description": "Number of matched documents",
                    "type": "number"
                },
                "nModified": {
                    "description": "Number of documents updated physically on disk",
                    "type": "number"
                },
                "nRemoved": {
                    "description": "Number of removed documents",
                    "type": "number"
                },
                "nUpserted": {
                    "description": "Number of upserted documents",
                    "type": "number"
                },
                "ok": {
                    "description": "Evaluates to true if the bulk operation correctly executes",
                    "type": "number"
                },
                "result": {
                    "$ref": "#/definitions/BulkResult"
                },
                "upsertedCount": {
                    "description": "Number of documents upserted.",
                    "type": "number"
                },
                "upsertedIds": {
                    "additionalProperties": false,
                    "description": "Upserted document generated Id's, hash key is the index of the originating operation",
                    "patternProperties": {
                        "^[0-9]+$": {}
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "CancellationToken": {
            "type": "object"
        },
        "ChangeStream<any,any>": {
            "description": "Creates a new Change Stream instance. Normally created using {@link Collection#watch Collection.watch()}.",
            "properties": {
                "closed": {
                    "description": "Is the cursor closed",
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "options": {
                    "$ref": "#/definitions/ChangeStreamOptions"
                },
                "parent": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Db"
                        },
                        {
                            "$ref": "#/definitions/MongoClient"
                        },
                        {
                            "$ref": "#/definitions/Collection<Document>_1"
                        }
                    ]
                },
                "pipeline": {
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "resumeToken": {
                    "description": "The cached resume token that is used to resume after the most recently returned change."
                },
                "streamOptions": {
                    "$ref": "#/definitions/CursorStreamOptions"
                },
                "type": {
                    "type": "object"
                }
            },
            "type": "object"
        },
        "ChangeStreamOptions": {
            "description": "Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.",
            "properties": {
                "allowDiskUse": {
                    "description": "allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>).",
                    "type": "boolean"
                },
                "authdb": {
                    "type": "string"
                },
                "batchSize": {
                    "description": "The number of documents to return per batch.",
                    "type": "number"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "bypassDocumentValidation": {
                    "description": "Allow driver to bypass schema validation in MongoDB 3.2 or higher.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Specify collation."
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "cursor": {
                    "$ref": "#/definitions/Document",
                    "description": "Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor."
                },
                "dbName": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullDocument": {
                    "description": "Allowed values: 'updateLookup', 'whenAvailable', 'required'.\n\nWhen set to 'updateLookup', the change notification for partial updates\nwill include both a delta describing the changes to the document as well\nas a copy of the entire document that was changed from some time after\nthe change occurred.\n\nWhen set to 'whenAvailable', configures the change stream to return the\npost-image of the modified document for replace and update change events\nif the post-image for this event is available.\n\nWhen set to 'required', the same behavior as 'whenAvailable' except that\nan error is raised if the post-image is not available.",
                    "type": "string"
                },
                "fullDocumentBeforeChange": {
                    "description": "Allowed values: 'whenAvailable', 'required', 'off'.\n\nThe default is to not send a value, which is equivalent to 'off'.\n\nWhen set to 'whenAvailable', configures the change stream to return the\npre-image of the modified document for replace, update, and delete change\nevents if it is available.\n\nWhen set to 'required', the same behavior as 'whenAvailable' except that\nan error is raised if the pre-image is not available.",
                    "type": "string"
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Add an index selection hint to an aggregation command"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "let": {
                    "$ref": "#/definitions/Document",
                    "description": "Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0)."
                },
                "maxAwaitTimeMS": {
                    "description": "The maximum amount of time for the server to wait on new documents to satisfy a change stream query.",
                    "type": "number"
                },
                "maxTimeMS": {
                    "description": "specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.",
                    "type": "number"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "out": {
                    "type": "string"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest)."
                },
                "resumeAfter": {
                    "description": "Allows you to start a changeStream after a specified event."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "$ref": "#/definitions/ClientSession",
                    "description": "Specify ClientSession for this command"
                },
                "showExpandedEvents": {
                    "description": "When enabled, configures the change stream to include extra change events.\n\n- createIndexes\n- dropIndexes\n- modify\n- create\n- shardCollection\n- reshardCollection\n- refineCollectionShardKey",
                    "type": "boolean"
                },
                "startAfter": {
                    "description": "Similar to resumeAfter, but will allow you to start after an invalidated event."
                },
                "startAtOperationTime": {
                    "$ref": "#/definitions/Timestamp",
                    "description": "Will start the changeStream after the specified operationTime."
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "ClientMetadata": {
            "properties": {
                "application": {
                    "properties": {
                        "name": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "driver": {
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "env": {
                    "description": "FaaS environment information",
                    "properties": {
                        "memory_mb": {
                            "$ref": "#/definitions/Int32",
                            "description": "A class representation of a BSON Int32 type."
                        },
                        "name": {
                            "enum": [
                                "aws.lambda",
                                "azure.func",
                                "gcp.func",
                                "vercel"
                            ],
                            "type": "string"
                        },
                        "region": {
                            "type": "string"
                        },
                        "timeout_sec": {
                            "$ref": "#/definitions/Int32",
                            "description": "A class representation of a BSON Int32 type."
                        },
                        "url": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "os": {
                    "properties": {
                        "architecture": {
                            "type": "string"
                        },
                        "name": {
                            "enum": [
                                "aix",
                                "android",
                                "cygwin",
                                "darwin",
                                "freebsd",
                                "haiku",
                                "linux",
                                "netbsd",
                                "openbsd",
                                "sunos",
                                "win32"
                            ],
                            "type": "string"
                        },
                        "type": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "platform": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ClientSession": {
            "description": "A class representing a client session on the server\n\nNOTE: not meant to be instantiated directly.",
            "properties": {
                "clientOptions": {
                    "$ref": "#/definitions/MongoOptions",
                    "description": "Parsed Mongo Client Options.\n\nUser supplied options are documented by `MongoClientOptions`.\n\n**NOTE:** The client's options parsing is subject to change to support new features.\nThis type is provided to aid with inspection of options after parsing, it should not be relied upon programmatically.\n\nOptions are sourced from:\n- connection string\n- options object passed to the MongoClient constructor\n- file system (ex. tls settings)\n- environment variables\n- DNS SRV records and TXT records\n\nNot all options may be present after client construction as some are obtained from asynchronous operations."
                },
                "clusterTime": {
                    "$ref": "#/definitions/ClusterTime"
                },
                "defaultTransactionOptions": {
                    "$ref": "#/definitions/TransactionOptions"
                },
                "explicit": {
                    "type": "boolean"
                },
                "hasEnded": {
                    "type": "boolean"
                },
                "id": {
                    "description": "The server id associated with this session",
                    "properties": {
                        "id": {
                            "$ref": "#/definitions/Binary"
                        }
                    },
                    "type": "object"
                },
                "isPinned": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "operationTime": {
                    "$ref": "#/definitions/Timestamp"
                },
                "serverSession": {
                    "$ref": "#/definitions/ServerSession"
                },
                "snapshotEnabled": {
                    "description": "Whether or not this session is configured for snapshot reads",
                    "type": "boolean"
                },
                "supports": {
                    "properties": {
                        "causalConsistency": {
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "transaction": {
                    "$ref": "#/definitions/Transaction"
                }
            },
            "type": "object"
        },
        "ClusterTime": {
            "properties": {
                "clusterTime": {
                    "$ref": "#/definitions/Timestamp"
                },
                "signature": {
                    "properties": {
                        "hash": {
                            "$ref": "#/definitions/Binary"
                        },
                        "keyId": {
                            "$ref": "#/definitions/Long"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Code": {
            "description": "A class representation of the BSON Code type.",
            "properties": {
                "_bsontype": {
                    "const": "Code",
                    "type": "string"
                },
                "code": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "scope": {
                    "$ref": "#/definitions/Document"
                }
            },
            "type": "object"
        },
        "CollationOptions": {
            "properties": {
                "alternate": {
                    "type": "string"
                },
                "backwards": {
                    "type": "boolean"
                },
                "caseFirst": {
                    "type": "string"
                },
                "caseLevel": {
                    "type": "boolean"
                },
                "locale": {
                    "type": "string"
                },
                "maxVariable": {
                    "type": "string"
                },
                "normalization": {
                    "type": "boolean"
                },
                "numericOrdering": {
                    "type": "boolean"
                },
                "strength": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Collection<Document>": {
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "collectionName": {
                    "description": "The collection name",
                    "type": "string"
                },
                "conn": {
                    "$ref": "#/definitions/Connection",
                    "description": "The Connection instance"
                },
                "dbName": {
                    "description": "The name of the database this collection belongs to",
                    "type": "string"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The current index hint for the collection"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "name": {
                    "description": "The collection name",
                    "type": "string"
                },
                "namespace": {
                    "description": "The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`",
                    "type": "string"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "The current readConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "The current writeConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                }
            },
            "type": "object"
        },
        "Collection<Document>_1": {
            "description": "The **Collection** class is an internal class that embodies a MongoDB collection\nallowing for insert/find/update/delete and other command operation on that MongoDB collection.\n\n**COLLECTION Cannot directly be instantiated**",
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "collectionName": {
                    "description": "The name of this collection",
                    "type": "string"
                },
                "dbName": {
                    "description": "The name of the database this collection belongs to",
                    "type": "string"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The current index hint for the collection"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "namespace": {
                    "description": "The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`",
                    "type": "string"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "The current readConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "The current writeConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                }
            },
            "type": "object"
        },
        "Collection<GridFSChunk>": {
            "description": "The **Collection** class is an internal class that embodies a MongoDB collection\nallowing for insert/find/update/delete and other command operation on that MongoDB collection.\n\n**COLLECTION Cannot directly be instantiated**",
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "collectionName": {
                    "description": "The name of this collection",
                    "type": "string"
                },
                "dbName": {
                    "description": "The name of the database this collection belongs to",
                    "type": "string"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The current index hint for the collection"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "namespace": {
                    "description": "The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`",
                    "type": "string"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "The current readConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "The current writeConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                }
            },
            "type": "object"
        },
        "Collection<GridFSFile>": {
            "description": "The **Collection** class is an internal class that embodies a MongoDB collection\nallowing for insert/find/update/delete and other command operation on that MongoDB collection.\n\n**COLLECTION Cannot directly be instantiated**",
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "collectionName": {
                    "description": "The name of this collection",
                    "type": "string"
                },
                "dbName": {
                    "description": "The name of the database this collection belongs to",
                    "type": "string"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The current index hint for the collection"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "namespace": {
                    "description": "The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`",
                    "type": "string"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "The current readConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "The current writeConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                }
            },
            "type": "object"
        },
        "Collection<any>": {
            "description": "The **Collection** class is an internal class that embodies a MongoDB collection\nallowing for insert/find/update/delete and other command operation on that MongoDB collection.\n\n**COLLECTION Cannot directly be instantiated**",
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "collectionName": {
                    "description": "The name of this collection",
                    "type": "string"
                },
                "dbName": {
                    "description": "The name of the database this collection belongs to",
                    "type": "string"
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The current index hint for the collection"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "namespace": {
                    "description": "The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`",
                    "type": "string"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "The current readConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "The current writeConcern of the collection. If not explicitly defined for\nthis collection, will be inherited from the parent DB"
                }
            },
            "type": "object"
        },
        "CommandFailedEvent": {
            "description": "An event indicating the failure of a given command",
            "properties": {
                "address": {
                    "type": "string"
                },
                "commandName": {
                    "type": "string"
                },
                "connectionId": {
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "duration": {
                    "type": "number"
                },
                "failure": {
                    "$ref": "#/definitions/Error_1"
                },
                "hasServiceId": {
                    "type": "boolean"
                },
                "requestId": {
                    "type": "number"
                },
                "serviceId": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "A class representation of the BSON ObjectId type."
                }
            },
            "type": "object"
        },
        "CommandStartedEvent": {
            "description": "An event indicating the start of a given",
            "properties": {
                "address": {
                    "type": "string"
                },
                "command": {
                    "$ref": "#/definitions/Document"
                },
                "commandName": {
                    "type": "string"
                },
                "commandObj": {
                    "$ref": "#/definitions/Document"
                },
                "connectionId": {
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "databaseName": {
                    "type": "string"
                },
                "hasServiceId": {
                    "type": "boolean"
                },
                "requestId": {
                    "type": "number"
                },
                "serviceId": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "A class representation of the BSON ObjectId type."
                }
            },
            "type": "object"
        },
        "CommandSucceededEvent": {
            "description": "An event indicating the success of a given command",
            "properties": {
                "address": {
                    "type": "string"
                },
                "commandName": {
                    "type": "string"
                },
                "connectionId": {
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "duration": {
                    "type": "number"
                },
                "hasServiceId": {
                    "type": "boolean"
                },
                "reply": {},
                "requestId": {
                    "type": "number"
                },
                "serviceId": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "A class representation of the BSON ObjectId type."
                }
            },
            "type": "object"
        },
        "Connection": {
            "properties": {
                "collections": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Collection<Document>"
                    },
                    "description": "A hash of the collections associated with this connection",
                    "type": "object"
                },
                "config": {
                    "description": "A hash of the global options that are associated with this connection"
                },
                "db": {
                    "$ref": "#/definitions/Db",
                    "description": "The mongodb.Db instance, set when the connection is opened"
                },
                "host": {
                    "description": "The host name portion of the URI. If multiple hosts, such as a replica set,\nthis will contain the first host name in the URI",
                    "type": "string"
                },
                "id": {
                    "description": "A number identifier for this connection. Used for debugging when\nyou have [multiple connections](/docs/connections.html#multiple_connections).",
                    "type": "number"
                },
                "models": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Model<any,{},{},{},any>"
                    },
                    "description": "A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\na map from model names to models. Contains all models that have been\nadded to this connection using [`Connection#model()`](/docs/api/connection.html#connection_Connection-model).",
                    "type": "object"
                },
                "name": {
                    "description": "The name of the database this connection points to.",
                    "type": "string"
                },
                "pass": {
                    "description": "The password specified in the URI",
                    "type": "string"
                },
                "plugins": {
                    "description": "The plugins that will be applied to all models created on this connection.",
                    "items": {},
                    "type": "array"
                },
                "port": {
                    "description": "The port portion of the URI. If multiple hosts, such as a replica set,\nthis will contain the port from the first host name in the URI.",
                    "type": "number"
                },
                "readyState": {
                    "$ref": "#/definitions/ConnectionStates",
                    "description": "Connection ready state\n\n- 0 = disconnected\n- 1 = connected\n- 2 = connecting\n- 3 = disconnecting\n- 99 = uninitialized"
                },
                "user": {
                    "description": "The username specified in the URI",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionCheckOutFailedEvent": {
            "description": "An event published when a request to check a connection out fails",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "reason": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error_1"
                        },
                        {
                            "$ref": "#/definitions/MongoError"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The reason the attempt to check out failed"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionCheckOutStartedEvent": {
            "description": "An event published when a request to check a connection out begins",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionCheckedInEvent": {
            "description": "An event published when a connection is checked into the connection pool",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "connectionId": {
                    "anyOf": [
                        {
                            "const": "<monitor>",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The id of the connection"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionCheckedOutEvent": {
            "description": "An event published when a connection is checked out of the connection pool",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "connectionId": {
                    "anyOf": [
                        {
                            "const": "<monitor>",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The id of the connection"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionClosedEvent": {
            "description": "An event published when a connection is closed",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "connectionId": {
                    "anyOf": [
                        {
                            "const": "<monitor>",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The id of the connection"
                },
                "reason": {
                    "description": "The reason the connection was closed",
                    "type": "string"
                },
                "serviceId": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "A class representation of the BSON ObjectId type."
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionCreatedEvent": {
            "description": "An event published when a connection pool creates a new connection",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "connectionId": {
                    "anyOf": [
                        {
                            "const": "<monitor>",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "A monotonically increasing, per-pool id for the newly created connection"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionPoolClearedEvent": {
            "description": "An event published when a connection pool is cleared",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "interruptInUseConnections": {
                    "type": "boolean"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionPoolClosedEvent": {
            "description": "An event published when a connection pool is closed",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionPoolCreatedEvent": {
            "description": "An event published when a connection pool is created",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "options": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/Omit<ConnectionPoolOptions,\"credentials\">"
                        },
                        {
                            "properties": {
                                "credentials": {
                                    "$ref": "#/definitions/Record<never,never>"
                                }
                            },
                            "type": "object"
                        }
                    ],
                    "description": "The options used to create this connection pool"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionPoolMonitoringEvent": {
            "description": "The base export class for all monitoring events published from the connection pool",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionPoolReadyEvent": {
            "description": "An event published when a connection pool is ready",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionReadyEvent": {
            "description": "An event published when a connection is ready for use",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the pool",
                    "type": "string"
                },
                "connectionId": {
                    "anyOf": [
                        {
                            "const": "<monitor>",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The id of the connection"
                },
                "time": {
                    "description": "A timestamp when the event was created",
                    "format": "date-time",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ConnectionStates": {
            "description": "Connection ready state\n\n- 0 = disconnected\n- 1 = connected\n- 2 = connecting\n- 3 = disconnecting\n- 99 = uninitialized",
            "enum": [
                0,
                1,
                2,
                3,
                99
            ],
            "type": "number"
        },
        "ConnectionStates.connected": {
            "const": 1,
            "type": "number"
        },
        "ConnectionStates.connecting": {
            "const": 2,
            "type": "number"
        },
        "ConnectionStates.disconnected": {
            "const": 0,
            "type": "number"
        },
        "ConnectionStates.disconnecting": {
            "const": 3,
            "type": "number"
        },
        "ConnectionStates.uninitialized": {
            "const": 99,
            "type": "number"
        },
        "Cursor<any,any>": {
            "properties": {
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "options": {},
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "CursorStreamOptions": {
            "type": "object"
        },
        "DBRef": {
            "description": "A class representation of the BSON DBRef type.",
            "properties": {
                "_bsontype": {
                    "const": "DBRef",
                    "type": "string"
                },
                "collection": {
                    "type": "string"
                },
                "db": {
                    "type": "string"
                },
                "fields": {
                    "$ref": "#/definitions/Document"
                },
                "oid": {
                    "$ref": "#/definitions/ObjectID"
                }
            },
            "type": "object"
        },
        "Db": {
            "description": "The **Db** class is a class that represents a MongoDB Database.",
            "properties": {
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "databaseName": {
                    "type": "string"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "namespace": {
                    "type": "string"
                },
                "options": {
                    "$ref": "#/definitions/DbOptions"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference",
                    "description": "The current readPreference of the Db. If not explicitly defined for\nthis Db, will be inherited from the parent MongoClient"
                },
                "secondaryOk": {
                    "description": "Check if a secondary can be used (because the read preference is *not* set to primary)",
                    "type": "boolean"
                },
                "slaveOk": {
                    "description": "slaveOk specified",
                    "type": "boolean"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                }
            },
            "type": "object"
        },
        "DbOptions": {
            "properties": {
                "authSource": {
                    "description": "If the database authentication is dependent on another databaseName.",
                    "type": "string"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "forceServerObjectId": {
                    "description": "Force server to assign _id values instead of driver.",
                    "type": "boolean"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "logger": {
                    "type": "object"
                },
                "loggerLevel": {
                    "enum": [
                        "debug",
                        "error",
                        "info",
                        "warn"
                    ],
                    "type": "string"
                },
                "pkFactory": {
                    "$ref": "#/definitions/PkFactory",
                    "description": "A primary key factory object for generation of custom _id keys."
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern",
                    "description": "Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST)."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "Decimal128": {
            "description": "A class representation of the BSON Decimal128 type.",
            "properties": {
                "_bsontype": {
                    "const": "Decimal128",
                    "type": "string"
                },
                "bytes": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "DeleteStatement": {
            "properties": {
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Specifies the collation to use for the operation."
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "A document or string that specifies the index to use to support the query predicate."
                },
                "limit": {
                    "description": "The number of matching documents to delete.",
                    "type": "number"
                },
                "q": {
                    "$ref": "#/definitions/Document",
                    "description": "The query that matches documents to delete."
                }
            },
            "type": "object"
        },
        "Document": {
            "additionalProperties": {},
            "type": "object"
        },
        "Document<any,any,any>": {
            "description": "Generic types for Document:\n*  T - the type of _id\n*  TQueryHelpers - Object with any helpers that should be mixed into the Query type\n*  DocType - the type of the actual Document created",
            "properties": {
                "$locals": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Empty object that you can use for storing properties on the document. This\nis handy for passing data to middleware without conflicting with Mongoose\ninternals."
                },
                "$op": {
                    "anyOf": [
                        {
                            "enum": [
                                "remove",
                                "save",
                                "validate"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "A string containing the current operation that Mongoose is executing\non this document. Can be `null`, `'save'`, `'validate'`, or `'remove'`."
                },
                "$where": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Set this property to add additional query filters when Mongoose saves this document and `isNew` is false."
                },
                "__v": {
                    "description": "This documents __v."
                },
                "_id": {
                    "description": "This documents _id."
                },
                "baseModelName": {
                    "description": "If this is a discriminator model, `baseModelName` is the name of the base model.",
                    "type": "string"
                },
                "collection": {
                    "$ref": "#/definitions/Collection<Document>",
                    "description": "Collection the model uses."
                },
                "db": {
                    "$ref": "#/definitions/Connection",
                    "description": "Connection the model uses."
                },
                "errors": {
                    "$ref": "#/definitions/Error.ValidationError",
                    "description": "Returns the current validation errors."
                },
                "id": {
                    "description": "The string version of this documents _id."
                },
                "isNew": {
                    "description": "Boolean flag specifying if the document is new.",
                    "type": "boolean"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The document's schema."
                }
            },
            "type": "object"
        },
        "Double": {
            "description": "A class representation of the BSON Double type.",
            "properties": {
                "_bsontype": {
                    "const": "Double",
                    "type": "string"
                },
                "value": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "DriverInfo": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "platform": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Duplex": {
            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Error": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.CastError": {
            "properties": {
                "kind": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "model": {},
                "name": {
                    "const": "CastError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "reason": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeError"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "stack": {
                    "type": "string"
                },
                "stringValue": {
                    "type": "string"
                },
                "value": {}
            },
            "type": "object"
        },
        "Error.DisconnectedError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "DisconnectedError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.DivergentArrayError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "DivergentArrayError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.DocumentNotFoundError": {
            "properties": {
                "filter": {},
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "DocumentNotFoundError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "numAffected": {
                    "type": "number"
                },
                "query": {},
                "result": {},
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.MissingSchemaError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "MissingSchemaError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.MongooseServerSelectionError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "MongooseServerSelectionError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ObjectExpectedError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ObjectExpectedError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ObjectParameterError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ObjectParameterError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.OverwriteModelError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "OverwriteModelError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ParallelSaveError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ParallelSaveError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ParallelValidateError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ParallelValidateError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.StrictModeError": {
            "properties": {
                "isImmutableError": {
                    "type": "boolean"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "StrictModeError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.StrictPopulateError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "StrictPopulateError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.SyncIndexesError": {
            "properties": {
                "errors": {
                    "$ref": "#/definitions/Record<string,MongoServerError>"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "SyncIndexesError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ValidationError": {
            "properties": {
                "addError": {
                    "type": "object"
                },
                "errors": {
                    "additionalProperties": {
                        "anyOf": [
                            {
                                "$ref": "#/definitions/Error.CastError"
                            },
                            {
                                "$ref": "#/definitions/Error.ValidatorError"
                            }
                        ]
                    },
                    "type": "object"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ValidationError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Error.ValidatorError": {
            "properties": {
                "kind": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "const": "ValidatorError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "properties": {
                    "properties": {
                        "message": {
                            "type": "string"
                        },
                        "path": {
                            "type": "string"
                        },
                        "reason": {},
                        "type": {
                            "type": "string"
                        },
                        "value": {}
                    },
                    "type": "object"
                },
                "reason": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/MongooseError"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "stack": {
                    "type": "string"
                },
                "value": {}
            },
            "type": "object"
        },
        "Error.VersionError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "modifiedPaths": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "name": {
                    "const": "VersionError",
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "version": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Error_1": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "EventEmitterAsyncResource": {
            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves.",
            "properties": {
                "asyncId": {
                    "description": "The unique asyncId assigned to the resource.",
                    "type": "number"
                },
                "asyncResource": {
                    "$ref": "#/definitions/EventEmitterReferencingAsyncResource",
                    "description": "The underlying AsyncResource"
                },
                "triggerAsyncId": {
                    "description": "The same triggerAsyncId that is passed to the AsyncResource constructor.",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "EventEmitterReferencingAsyncResource": {
            "properties": {
                "eventEmitter": {
                    "$ref": "#/definitions/EventEmitterAsyncResource"
                }
            },
            "type": "object"
        },
        "FindCursor<any>": {
            "properties": {
                "closed": {
                    "type": "boolean"
                },
                "id": {
                    "$ref": "#/definitions/Long"
                },
                "killed": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                }
            },
            "type": "object"
        },
        "FindOperators": {
            "description": "A builder object that is returned from {@link BulkOperationBase#find}.\nIs used to build a write operation that involves a query filter.",
            "properties": {
                "bulkOperation": {
                    "$ref": "#/definitions/BulkOperationBase"
                }
            },
            "type": "object"
        },
        "Function": {
            "properties": {
                "arguments": {},
                "caller": {
                    "$ref": "#/definitions/Function"
                },
                "length": {
                    "type": "number"
                },
                "name": {
                    "type": "string"
                },
                "prototype": {}
            },
            "type": "object"
        },
        "GridFSBucket": {
            "description": "Constructor for a streaming GridFS interface",
            "type": "object"
        },
        "GridFSBucketReadStream": {
            "description": "A readable stream that enables you to read buffers from GridFS.\n\nDo not instantiate this class directly. Use `openDownloadStream()` instead.",
            "properties": {
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "GridFSBucketWriteStream": {
            "description": "A writable stream that enables you to write buffers to GridFS.\n\nDo not instantiate this class directly. Use `openUploadStream()` instead.",
            "properties": {
                "bucket": {
                    "$ref": "#/definitions/GridFSBucket"
                },
                "bufToStore": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "chunkSizeBytes": {
                    "type": "number"
                },
                "chunks": {
                    "$ref": "#/definitions/Collection<GridFSChunk>"
                },
                "destroyed": {
                    "description": "Is `true` after `writable.destroy()` has been called.",
                    "type": "boolean"
                },
                "done": {
                    "type": "boolean"
                },
                "filename": {
                    "type": "string"
                },
                "files": {
                    "$ref": "#/definitions/Collection<GridFSFile>"
                },
                "id": {
                    "$ref": "#/definitions/ObjectID"
                },
                "length": {
                    "type": "number"
                },
                "n": {
                    "type": "number"
                },
                "options": {
                    "$ref": "#/definitions/GridFSBucketWriteStreamOptions"
                },
                "pos": {
                    "type": "number"
                },
                "state": {
                    "properties": {
                        "aborted": {
                            "type": "boolean"
                        },
                        "errored": {
                            "type": "boolean"
                        },
                        "outstandingRequests": {
                            "type": "number"
                        },
                        "streamEnd": {
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "A MongoDB WriteConcern, which describes the level of acknowledgement\nrequested from MongoDB for write operations."
                }
            },
            "type": "object"
        },
        "GridFSBucketWriteStreamOptions": {
            "properties": {
                "aliases": {
                    "description": "Array of strings to store in the file document's `aliases` field",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "chunkSizeBytes": {
                    "description": "Overwrite this bucket's chunkSizeBytes for this file",
                    "type": "number"
                },
                "contentType": {
                    "description": "String to store in the file document's `contentType` field",
                    "type": "string"
                },
                "id": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "Custom file id for the GridFS file."
                },
                "metadata": {
                    "$ref": "#/definitions/Document",
                    "description": "Object to store in the file document's `metadata` field"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "HedgeOptions": {
            "properties": {
                "enabled": {
                    "description": "Explicitly enable or disable hedged reads.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "HostAddress": {
            "properties": {
                "host": {
                    "type": "string"
                },
                "isIPv6": {
                    "type": "boolean"
                },
                "port": {
                    "type": "number"
                },
                "socketPath": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "IndexOptions": {
            "properties": {
                "2dsphereIndexVersion": {
                    "type": "number"
                },
                "authdb": {
                    "type": "string"
                },
                "background": {
                    "description": "Creates the index in the background, yielding whenever possible.",
                    "type": "boolean"
                },
                "bits": {
                    "type": "number"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "bucketSize": {
                    "type": "number"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Collation"
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "commitQuorum": {
                    "description": "(MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "dbName": {
                    "type": "string"
                },
                "default_language": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "expireAfterSeconds": {
                    "description": "Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)",
                    "type": "number"
                },
                "expires": {
                    "description": "`expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "hidden": {
                    "description": "Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher)",
                    "type": "boolean"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "language_override": {
                    "type": "string"
                },
                "max": {
                    "description": "For geospatial indexes set the high bound for the co-ordinates.",
                    "type": "number"
                },
                "maxTimeMS": {
                    "type": "number"
                },
                "min": {
                    "description": "For geospatial indexes set the lower bound for the co-ordinates.",
                    "type": "number"
                },
                "name": {
                    "description": "Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)",
                    "type": "string"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "partialFilterExpression": {
                    "$ref": "#/definitions/Document",
                    "description": "Creates a partial index based on the given filter object (MongoDB 3.2 or higher)"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest)."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "$ref": "#/definitions/ClientSession",
                    "description": "Specify ClientSession for this command"
                },
                "sparse": {
                    "description": "Creates a sparse index.",
                    "type": "boolean"
                },
                "storageEngine": {
                    "$ref": "#/definitions/Document",
                    "description": "Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher)"
                },
                "textIndexVersion": {
                    "type": "number"
                },
                "unique": {
                    "description": "Creates an unique index.",
                    "type": "boolean"
                },
                "version": {
                    "description": "Specifies the index version number, either 0 or 1.",
                    "type": "number"
                },
                "weights": {
                    "$ref": "#/definitions/Record<string,number>"
                },
                "wildcardProjection": {
                    "$ref": "#/definitions/Document"
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "Int32": {
            "description": "A class representation of a BSON Int32 type.",
            "properties": {
                "_bsontype": {
                    "const": "Int32",
                    "type": "string"
                },
                "value": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "KeyObject": {
            "properties": {
                "passphrase": {
                    "description": "Optional passphrase.",
                    "type": "string"
                },
                "pem": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format."
                }
            },
            "type": "object"
        },
        "LegacyAsyncValidateFn<Schema.Types.Mixed>": {
            "type": "object"
        },
        "LegacyAsyncValidateFn<any>": {
            "type": "object"
        },
        "ListCollectionsCursor<any>": {
            "properties": {
                "closed": {
                    "type": "boolean"
                },
                "filter": {
                    "$ref": "#/definitions/Document"
                },
                "id": {
                    "$ref": "#/definitions/Long"
                },
                "killed": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "options": {
                    "$ref": "#/definitions/ListCollectionsOptions"
                },
                "parent": {
                    "$ref": "#/definitions/Db"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                }
            },
            "type": "object"
        },
        "ListCollectionsOptions": {
            "properties": {
                "authdb": {
                    "type": "string"
                },
                "authorizedCollections": {
                    "description": "Since 4.0: If true and nameOnly is true, allows a user without the required privilege (i.e. listCollections action on the database) to run the command when access control is enforced.",
                    "type": "boolean"
                },
                "batchSize": {
                    "description": "The batchSize for the returned command cursor or if pre 2.8 the systems batch collection",
                    "type": "number"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Collation"
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "dbName": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "maxTimeMS": {
                    "type": "number"
                },
                "nameOnly": {
                    "description": "Since 4.0: If true, will only return the collection name in the response, and will omit additional info",
                    "type": "boolean"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest)."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "$ref": "#/definitions/ClientSession",
                    "description": "Specify ClientSession for this command"
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "ListIndexesCursor": {
            "properties": {
                "closed": {
                    "type": "boolean"
                },
                "id": {
                    "$ref": "#/definitions/Long"
                },
                "killed": {
                    "type": "boolean"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "namespace": {
                    "$ref": "#/definitions/MongoDBNamespace"
                },
                "options": {
                    "$ref": "#/definitions/ListIndexesOptions"
                },
                "parent": {
                    "$ref": "#/definitions/Collection<Document>_1"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                }
            },
            "type": "object"
        },
        "ListIndexesOptions": {
            "properties": {
                "authdb": {
                    "type": "string"
                },
                "batchSize": {
                    "description": "The batchSize for the returned command cursor or if pre 2.8 the systems batch collection",
                    "type": "number"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Collation"
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "dbName": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "maxTimeMS": {
                    "type": "number"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported)"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest)."
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "$ref": "#/definitions/ClientSession",
                    "description": "Specify ClientSession for this command"
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/WriteConcern"
                        },
                        {
                            "$ref": "#/definitions/WriteConcernSettings"
                        }
                    ],
                    "description": "Write Concern as an object"
                }
            },
            "type": "object"
        },
        "Logger": {
            "properties": {
                "className": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Long": {
            "description": "A class representing a 64-bit integer",
            "properties": {
                "__isLong__": {
                    "const": true,
                    "description": "An indicator used to reliably determine if an object is a Long or not.",
                    "type": "boolean"
                },
                "_bsontype": {
                    "const": "Long",
                    "type": "string"
                },
                "high": {
                    "description": "The high 32 bits as a signed value.",
                    "type": "number"
                },
                "low": {
                    "description": "The low 32 bits as a signed value.",
                    "type": "number"
                },
                "unsigned": {
                    "description": "Whether unsigned or not.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Map<any,any>": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Map<string,ServerDescription>": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "MapConstructor": {
            "properties": {
                "__@species@1110": {
                    "$ref": "#/definitions/MapConstructor"
                },
                "prototype": {
                    "$ref": "#/definitions/Map<any,any>"
                }
            },
            "type": "object"
        },
        "MaxKey": {
            "description": "A class representation of the BSON MaxKey type.",
            "properties": {
                "_bsontype": {
                    "const": "MaxKey",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MinKey": {
            "description": "A class representation of the BSON MinKey type.",
            "properties": {
                "_bsontype": {
                    "const": "MinKey",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MixedSchemaTypeOptions": {
            "properties": {
                "_id": {
                    "description": "If set, overrides the child schema's `_id` option. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "alias": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Defines a virtual with the given name that gets/sets this path."
                },
                "auto": {
                    "description": "If true, uses Mongoose's default `_id` settings. Only allowed for ObjectIds",
                    "type": "boolean"
                },
                "cast": {
                    "description": "Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.",
                    "type": "string"
                },
                "default": {
                    "description": "The default value for this path. If a function, Mongoose executes the function\nand uses the return value as the default."
                },
                "enum": {
                    "anyOf": [
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "message": {
                                    "type": "string"
                                },
                                "values": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        }
                                    ]
                                }
                            },
                            "type": "object"
                        },
                        {
                            "additionalProperties": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "object"
                        }
                    ],
                    "description": "array of allowed values for this path. Allowed for strings, numbers, and arrays of strings"
                },
                "excludeIndexes": {
                    "description": "If `true`, Mongoose will skip gathering indexes on subpaths. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "expires": {
                    "description": "Defines a TTL index on this path. Only allowed for dates.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "get": {
                    "description": "defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "immutable": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\ndisallow changes to this path once the document is saved to the database for the first time. Read more\nabout [immutability in Mongoose here](http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).",
                    "type": [
                        "object",
                        "boolean"
                    ]
                },
                "index": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/IndexOptions"
                        },
                        {
                            "enum": [
                                -1,
                                1,
                                "2d",
                                "2dsphere",
                                "asc",
                                "ascending",
                                "desc",
                                "descending",
                                false,
                                "geoHaystack",
                                "hashed",
                                "text",
                                true
                            ]
                        }
                    ],
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild an index on this path when the model is compiled."
                },
                "lowercase": {
                    "description": "If truthy, Mongoose will add a custom setter that lowercases this string using JavaScript's built-in `String#toLowerCase()`.",
                    "type": "boolean"
                },
                "match": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        }
                    ],
                    "description": "Attaches a validator that succeeds if the data string matches the given regular expression, and fails otherwise."
                },
                "max": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The maximum value allowed for this path. Only allowed for numbers and dates."
                },
                "maxlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at most the given number."
                },
                "min": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The minimum value allowed for this path. Only allowed for numbers and dates."
                },
                "minlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at least the given number."
                },
                "of": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/typeofSchemaType"
                        },
                        {
                            "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Function"
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Mixed"
                                },
                                "schemaName": {
                                    "const": "Mixed",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/MixedSchemaTypeOptions"
                        },
                        {
                            "$ref": "#/definitions/SchemaTypeOptions<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Number"
                                },
                                "schemaName": {
                                    "const": "Number",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/StringConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.String"
                                },
                                "schemaName": {
                                    "const": "String",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/BooleanConstructor"
                        },
                        {
                            "properties": {
                                "convertToFalse": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `false`."
                                },
                                "convertToTrue": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `true`."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Boolean"
                                },
                                "schemaName": {
                                    "const": "Boolean",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/NativeDate"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Date"
                                },
                                "schemaName": {
                                    "const": "Date",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaTypeOptions<any>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                                    },
                                    {
                                        "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "If set, specifies the type of this map's values. Mongoose will cast this map's values to the given type."
                },
                "ref": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Model<any,{},{},{},any>"
                        },
                        {
                            "type": [
                                "string",
                                "object"
                            ]
                        }
                    ],
                    "description": "The model that `populate()` should use if populating this path."
                },
                "refPath": {
                    "description": "The path in the document that `populate()` should use to find the model\nto use.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "required": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "object"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "If true, attach a required validator to this path, which ensures this path\npath cannot be set to a nullish value. If a function, Mongoose calls the\nfunction and only checks for nullish values if the function returns a truthy value."
                },
                "select": {
                    "description": "Whether to include or exclude this path by default when loading documents\nusing `find()`, `findOne()`, etc.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "set": {
                    "description": "defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "sparse": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild a sparse index on this path.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "subtype": {
                    "description": "The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths",
                    "type": "number"
                },
                "text": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a text index on this path."
                },
                "transform": {
                    "description": "Define a transform function for this individual schema type.\nOnly called when calling `toJSON()` or `toObject()`.",
                    "type": "object"
                },
                "trim": {
                    "description": "If truthy, Mongoose will add a custom setter that removes leading and trailing whitespace using JavaScript's built-in `String#trim()`.",
                    "type": "boolean"
                },
                "type": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Schema.Types.Mixed"
                        },
                        "schemaName": {
                            "const": "Mixed",
                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "unique": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a unique index on this path when the\nmodel is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "uppercase": {
                    "description": "If truthy, Mongoose will add a custom setter that uppercases this string using JavaScript's built-in `String#toUpperCase()`.",
                    "type": "boolean"
                },
                "validate": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/Function"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/ValidateOpts<Schema.Types.Mixed>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValidateOpts<Schema.Types.Mixed>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<Schema.Types.Mixed>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<Schema.Types.Mixed>"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html)."
                }
            },
            "type": "object"
        },
        "Model<any,{},{},{},any>": {
            "properties": {
                "base": {
                    "$ref": "#/definitions/typeofimport(\"mongoose\")",
                    "description": "Base Mongoose instance the model uses."
                },
                "baseModelName": {
                    "description": "If this is a discriminator model, `baseModelName` is the name of\nthe base model.",
                    "type": "string"
                },
                "collection": {
                    "$ref": "#/definitions/Collection<Document>",
                    "description": "Collection the model uses."
                },
                "db": {
                    "$ref": "#/definitions/Connection",
                    "description": "Connection the model uses."
                },
                "discriminators": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Model<any,{},{},{},any>"
                    },
                    "description": "Registered discriminators for this model.",
                    "type": "object"
                },
                "events": {
                    "$ref": "#/definitions/NodeJS.EventEmitter",
                    "description": "Event emitter that reports any errors that occurred. Useful for global error\nhandling."
                },
                "modelName": {
                    "description": "The name of the model",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "Schema the model uses."
                }
            },
            "type": "object"
        },
        "Models": {
            "additionalProperties": {
                "$ref": "#/definitions/Model<any,{},{},{},any>"
            },
            "description": "Can be extended to explicitly type specific models.",
            "type": "object"
        },
        "MongoAPIError": {
            "description": "An error generated when the driver API is used incorrectly",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoAWSError": {
            "description": "A error generated when the user attempts to authenticate\nvia AWS, but fails",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoBatchReExecutionError": {
            "description": "An error generated when a batch command is re-executed after one of the commands in the batch\nhas failed",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoBulkWriteError": {
            "description": "An error indicating an unsuccessful Bulk Write",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "codeName": {
                    "type": "string"
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "deletedCount": {
                    "description": "Number of documents deleted.",
                    "type": "number"
                },
                "err": {
                    "$ref": "#/definitions/WriteConcernError",
                    "description": "An error representing a failure by the server to apply the requested write concern to the bulk operation."
                },
                "errInfo": {
                    "$ref": "#/definitions/Document"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "insertedCount": {
                    "description": "Number of documents inserted.",
                    "type": "number"
                },
                "insertedIds": {
                    "additionalProperties": false,
                    "description": "Inserted document generated Id's, hash key is the index of the originating operation",
                    "patternProperties": {
                        "^[0-9]+$": {}
                    },
                    "type": "object"
                },
                "matchedCount": {
                    "description": "Number of documents matched for update.",
                    "type": "number"
                },
                "message": {
                    "type": "string"
                },
                "modifiedCount": {
                    "description": "Number of documents modified.",
                    "type": "number"
                },
                "name": {
                    "type": "string"
                },
                "ok": {
                    "type": "number"
                },
                "result": {
                    "$ref": "#/definitions/BulkWriteResult"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                },
                "upsertedCount": {
                    "description": "Number of documents upserted.",
                    "type": "number"
                },
                "upsertedIds": {
                    "additionalProperties": false,
                    "description": "Upserted document generated Id's, hash key is the index of the originating operation",
                    "patternProperties": {
                        "^[0-9]+$": {}
                    },
                    "type": "object"
                },
                "writeConcernError": {
                    "$ref": "#/definitions/Document"
                },
                "writeErrors": {
                    "$ref": "#/definitions/OneOrMore<WriteError>"
                }
            },
            "type": "object"
        },
        "MongoChangeStreamError": {
            "description": "An error generated when a ChangeStream operation fails to execute.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoClient": {
            "description": "The **MongoClient** class is a class that allows for making Connections to MongoDB.",
            "properties": {
                "_connect": {},
                "autoEncrypter": {
                    "$ref": "#/definitions/AutoEncrypter"
                },
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "logger": {
                    "$ref": "#/definitions/Logger"
                },
                "options": {
                    "$ref": "#/definitions/MongoOptions"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                },
                "serverApi": {
                    "$ref": "#/definitions/ServerApi"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                }
            },
            "type": "object"
        },
        "MongoCompatibilityError": {
            "description": "An error generated when a feature that is not enabled or allowed for the current server\nconfiguration is used",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoCredentials": {
            "description": "A representation of the credentials used by MongoDB",
            "properties": {
                "mechanism": {
                    "$ref": "#/definitions/AuthMechanism",
                    "description": "The method used to authenticate"
                },
                "mechanismProperties": {
                    "$ref": "#/definitions/AuthMechanismProperties",
                    "description": "Special properties used by some types of auth mechanisms"
                },
                "password": {
                    "description": "The password used for authentication",
                    "type": "string"
                },
                "source": {
                    "description": "The database that the user should authenticate against",
                    "type": "string"
                },
                "username": {
                    "description": "The username used for authentication",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MongoCursorExhaustedError": {
            "description": "An error thrown when an attempt is made to read from a cursor that has been exhausted",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoCursorInUseError": {
            "description": "An error thrown when the user attempts to add options to a cursor that has already been\ninitialized",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoDBNamespace": {
            "properties": {
                "collection": {
                    "type": "string"
                },
                "db": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MongoDecompressionError": {
            "description": "An error generated when the driver fails to decompress\ndata received from the server.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoDriverError": {
            "description": "An error generated by the driver",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoError": {
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoExpiredSessionError": {
            "description": "An error generated when the user attempts to operate\non a session that has expired or has been closed.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoGridFSChunkError": {
            "description": "An error generated when a malformed or invalid chunk is\nencountered when reading from a GridFSStream.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoGridFSStreamError": {
            "description": "An error generated when a GridFSStream operation fails to execute.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoInvalidArgumentError": {
            "description": "An error generated when the user supplies malformed or unexpected arguments\nor when a required argument or field is not provided.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoKerberosError": {
            "description": "A error generated when the user attempts to authenticate\nvia Kerberos, but fails to connect to the Kerberos client.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoMissingCredentialsError": {
            "description": "An error generated when the user fails to provide authentication credentials before attempting\nto connect to a mongo server instance.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoMissingDependencyError": {
            "description": "An error generated when a required module or dependency is not present in the local environment",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoNetworkError": {
            "description": "An error indicating an issue with the network, including TCP errors and timeouts.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoNetworkTimeoutError": {
            "description": "An error indicating a network timeout occurred",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoNotConnectedError": {
            "description": "An error thrown when the user attempts to operate on a database or collection through a MongoClient\nthat has not yet successfully called the \"connect\" method",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoOptions": {
            "description": "Parsed Mongo Client Options.\n\nUser supplied options are documented by `MongoClientOptions`.\n\n**NOTE:** The client's options parsing is subject to change to support new features.\nThis type is provided to aid with inspection of options after parsing, it should not be relied upon programmatically.\n\nOptions are sourced from:\n- connection string\n- options object passed to the MongoClient constructor\n- file system (ex. tls settings)\n- environment variables\n- DNS SRV records and TXT records\n\nNot all options may be present after client construction as some are obtained from asynchronous operations.",
            "properties": {
                "ALPNProtocols": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "additionalProperties": false,
                                "patternProperties": {
                                    "^[0-9]+$": {
                                        "type": "number"
                                    }
                                },
                                "properties": {
                                    "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                    },
                                    "__@toStringTag@1754": {
                                        "const": "Uint8Array",
                                        "type": "string"
                                    },
                                    "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                    },
                                    "byteLength": {
                                        "type": "number"
                                    },
                                    "byteOffset": {
                                        "type": "number"
                                    },
                                    "length": {
                                        "type": "number"
                                    }
                                },
                                "type": "object"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "An array of strings or a Buffer naming possible ALPN protocols.\n(Protocols should be ordered by their priority.)"
                },
                "appName": {
                    "type": "string"
                },
                "autoEncrypter": {
                    "$ref": "#/definitions/AutoEncrypter"
                },
                "autoEncryption": {
                    "$ref": "#/definitions/AutoEncryptionOptions",
                    "description": "Optionally enable in-use auto encryption"
                },
                "ca": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Optionally override the trusted CA certificates. Default is to trust\nthe well-known CAs curated by Mozilla. Mozilla's CAs are completely\nreplaced when CAs are explicitly specified using this option."
                },
                "cert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Cert chains in PEM format. One cert chain should be provided per\nprivate key. Each cert chain should consist of the PEM formatted\ncertificate for a provided private key, followed by the PEM\nformatted intermediate certificates (if any), in order, and not\nincluding the root CA (the root CA must be pre-known to the peer,\nsee ca). When providing multiple cert chains, they do not have to\nbe in the same order as their private keys in key. If the\nintermediate certificates are not provided, the peer will not be\nable to validate the certificate, and the handshake will fail."
                },
                "checkServerIdentity": {
                    "description": "Verifies the certificate `cert` is issued to `hostname`.\n\nReturns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on\nfailure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type).\n\nThis function can be overwritten by providing alternative function as part of\nthe `options.checkServerIdentity` option passed to `tls.connect()`. The\noverwriting function can call `tls.checkServerIdentity()` of course, to augment\nthe checks done with additional verification.\n\nThis function is only called if the certificate passed all other checks, such as\nbeing issued by trusted CA (`options.ca`).",
                    "type": "object"
                },
                "ciphers": {
                    "description": "Cipher suite specification, replacing the default. For more\ninformation, see modifying the default cipher suite. Permitted\nciphers can be obtained via tls.getCiphers(). Cipher names must be\nuppercased in order for OpenSSL to accept them.",
                    "type": "string"
                },
                "compressors": {
                    "items": {
                        "enum": [
                            "none",
                            "snappy",
                            "zlib",
                            "zstd"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "connectTimeoutMS": {
                    "description": "The time in milliseconds to attempt a connection before timing out.",
                    "type": "number"
                },
                "credentials": {
                    "$ref": "#/definitions/MongoCredentials",
                    "description": "A representation of the credentials used by MongoDB"
                },
                "crl": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                },
                "dbName": {
                    "type": "string"
                },
                "directConnection": {
                    "description": "Allow a driver to force a Single topology type with a connection string containing one host",
                    "type": "boolean"
                },
                "driverInfo": {
                    "$ref": "#/definitions/DriverInfo",
                    "description": "Allows a wrapping driver to amend the client metadata generated by the driver to include information about the wrapping driver"
                },
                "ecdhCurve": {
                    "description": "A string describing a named curve or a colon separated list of curve\nNIDs or names, for example P-521:P-384:P-256, to use for ECDH key\nagreement. Set to auto to select the curve automatically. Use\ncrypto.getCurves() to obtain a list of available curve names. On\nrecent releases, openssl ecparam -list_curves will also display the\nname and description of each available elliptic curve. Default:\ntls.DEFAULT_ECDH_CURVE.",
                    "type": "string"
                },
                "family": {
                    "type": "number"
                },
                "forceServerObjectId": {
                    "description": "Force server to assign `_id` values instead of driver",
                    "type": "boolean"
                },
                "heartbeatFrequencyMS": {
                    "description": "heartbeatFrequencyMS controls when the driver checks the state of the MongoDB deployment. Specify the interval (in milliseconds) between checks, counted from the end of the previous check until the beginning of the next one.",
                    "type": "number"
                },
                "hints": {
                    "type": "number"
                },
                "hosts": {
                    "items": {
                        "$ref": "#/definitions/HostAddress"
                    },
                    "type": "array"
                },
                "keepAlive": {
                    "description": "TCP Connection keep alive enabled",
                    "type": "boolean"
                },
                "keepAliveInitialDelay": {
                    "description": "The number of milliseconds to wait before initiating keepAlive on the TCP socket",
                    "type": "number"
                },
                "key": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/KeyObject"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format. PEM allows the option of private keys\nbeing encrypted. Encrypted keys will be decrypted with\noptions.passphrase. Multiple keys using different algorithms can be\nprovided either as an array of unencrypted key strings or buffers,\nor an array of objects in the form {pem: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted keys will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "localAddress": {
                    "type": "string"
                },
                "localPort": {
                    "type": "number"
                },
                "localThresholdMS": {
                    "description": "The size (in milliseconds) of the latency window for selecting among multiple suitable MongoDB instances.",
                    "type": "number"
                },
                "logger": {
                    "$ref": "#/definitions/Logger",
                    "description": "Custom logger object"
                },
                "lookup": {
                    "type": "object"
                },
                "maxConnecting": {
                    "description": "The maximum number of connections that may be in the process of being established concurrently by the connection pool.",
                    "type": "number"
                },
                "maxIdleTimeMS": {
                    "description": "The maximum number of milliseconds that a connection can remain idle in the pool before being removed and closed.",
                    "type": "number"
                },
                "maxPoolSize": {
                    "description": "The maximum number of connections in the connection pool.",
                    "type": "number"
                },
                "metadata": {
                    "$ref": "#/definitions/ClientMetadata"
                },
                "minDHSize": {
                    "type": "number"
                },
                "minHeartbeatFrequencyMS": {
                    "description": "Sets the minimum heartbeat frequency. In the event that the driver has to frequently re-check a server's availability, it will wait at least this long since the previous check to avoid wasted effort.",
                    "type": "number"
                },
                "minPoolSize": {
                    "description": "The minimum number of connections in the connection pool.",
                    "type": "number"
                },
                "monitorCommands": {
                    "description": "Enable command monitoring for this client",
                    "type": "boolean"
                },
                "noDelay": {
                    "description": "TCP Connection no delay",
                    "type": "boolean"
                },
                "passphrase": {
                    "description": "Shared passphrase used for a single private key and/or a PFX.",
                    "type": "string"
                },
                "pfx": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/PxfObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an\nalternative to providing key and cert individually. PFX is usually\nencrypted, if it is, passphrase will be used to decrypt it. Multiple\nPFX can be provided either as an array of unencrypted PFX buffers,\nor an array of objects in the form {buf: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted PFX will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "pkFactory": {
                    "$ref": "#/definitions/PkFactory",
                    "description": "A primary key factory function for generation of custom `_id` keys"
                },
                "promiseLibrary": {
                    "description": "A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible"
                },
                "proxyHost": {
                    "type": "string"
                },
                "proxyPassword": {
                    "type": "string"
                },
                "proxyPort": {
                    "type": "number"
                },
                "proxyUsername": {
                    "type": "string"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                },
                "rejectUnauthorized": {
                    "default": true,
                    "description": "If true the server will reject any connection which is not\nauthorized with the list of supplied CAs. This option only has an\neffect if requestCert is true.",
                    "type": "boolean"
                },
                "replicaSet": {
                    "description": "Specifies the name of the replica set, if the mongod is a member of a replica set.",
                    "type": "string"
                },
                "retryReads": {
                    "description": "Enables retryable reads.",
                    "type": "boolean"
                },
                "retryWrites": {
                    "description": "Enable retryable writes.",
                    "type": "boolean"
                },
                "secureContext": {
                    "$ref": "#/definitions/SecureContext",
                    "description": "An optional TLS context object from tls.createSecureContext()"
                },
                "secureProtocol": {
                    "description": "Legacy mechanism to select the TLS protocol version to use, it does\nnot support independent control of the minimum and maximum version,\nand does not support limiting the protocol to TLSv1.3. Use\nminVersion and maxVersion instead. The possible values are listed as\nSSL_METHODS, use the function names as strings. For example, use\n'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\nany TLS protocol version up to TLSv1.3. It is not recommended to use\nTLS versions less than 1.2, but it may be required for\ninteroperability. Default: none, see minVersion.",
                    "type": "string"
                },
                "serverApi": {
                    "$ref": "#/definitions/ServerApi"
                },
                "serverSelectionTimeoutMS": {
                    "description": "Specifies how long (in milliseconds) to block for server selection before throwing an exception.",
                    "type": "number"
                },
                "servername": {
                    "type": "string"
                },
                "session": {
                    "additionalProperties": false,
                    "description": "An optional Buffer instance containing a TLS session.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "socketTimeoutMS": {
                    "description": "The time in milliseconds to attempt a send or receive on a socket before the attempt times out.",
                    "type": "number"
                },
                "srvHost": {
                    "type": "string"
                },
                "srvMaxHosts": {
                    "description": "The maximum number of hosts to connect to when using an srv connection string, a setting of `0` means unlimited hosts",
                    "type": "number"
                },
                "srvServiceName": {
                    "description": "Modifies the srv URI to look like:\n\n`_{srvServiceName}._tcp.{hostname}.{domainname}`\n\nQuerying this DNS URI is expected to respond with SRV records",
                    "type": "string"
                },
                "tls": {
                    "description": "# NOTE ABOUT TLS Options\n\nIf set TLS enabled, equivalent to setting the ssl option.\n\n### Additional options:\n\n|    nodejs option     | MongoDB equivalent                                       | type                                   |\n|:---------------------|--------------------------------------------------------- |:---------------------------------------|\n| `ca`                 | `sslCA`, `tlsCAFile`                                     | `string \\| Buffer \\| Buffer[]`         |\n| `crl`                | `sslCRL`                                                 | `string \\| Buffer \\| Buffer[]`         |\n| `cert`               | `sslCert`, `tlsCertificateFile`, `tlsCertificateKeyFile` | `string \\| Buffer \\| Buffer[]`         |\n| `key`                | `sslKey`, `tlsCertificateKeyFile`                        | `string \\| Buffer \\| KeyObject[]`      |\n| `passphrase`         | `sslPass`, `tlsCertificateKeyFilePassword`               | `string`                               |\n| `rejectUnauthorized` | `sslValidate`                                            | `boolean`                              |",
                    "type": "boolean"
                },
                "tlsAllowInvalidCertificates": {
                    "description": "Bypasses validation of the certificates presented by the mongod/mongos instance",
                    "type": "boolean"
                },
                "tlsAllowInvalidHostnames": {
                    "description": "Disables hostname validation of the certificate presented by the mongod/mongos instance.",
                    "type": "boolean"
                },
                "tlsInsecure": {
                    "description": "Disables various certificate validations.",
                    "type": "boolean"
                },
                "waitQueueTimeoutMS": {
                    "description": "The maximum time in milliseconds that a thread can wait for a connection to become available.",
                    "type": "number"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                },
                "zlibCompressionLevel": {
                    "description": "An integer that specifies the compression level if using zlib for network compression.",
                    "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    "type": "number"
                }
            },
            "type": "object"
        },
        "MongoParseError": {
            "description": "An error used when attempting to parse a value (like a connection string)",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoRuntimeError": {
            "description": "An error generated when the driver encounters unexpected input\nor reaches an unexpected/invalid internal state",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoServerClosedError": {
            "description": "An error generated when an attempt is made to operate\non a closed/closing server.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoServerError": {
            "additionalProperties": {},
            "description": "An error coming from the mongo server",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "codeName": {
                    "type": "string"
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ok": {
                    "type": "number"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                },
                "writeConcernError": {
                    "$ref": "#/definitions/Document"
                }
            },
            "type": "object"
        },
        "MongoServerSelectionError": {
            "description": "An error signifying a client-side server selection error",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "reason": {
                    "$ref": "#/definitions/TopologyDescription",
                    "description": "An optional reason context, such as an error saved during flow of monitoring and selecting servers"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoSystemError": {
            "description": "An error signifying a general system issue",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "reason": {
                    "$ref": "#/definitions/TopologyDescription",
                    "description": "An optional reason context, such as an error saved during flow of monitoring and selecting servers"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoTailableCursorError": {
            "description": "An error thrown when the user calls a function or method not supported on a tailable cursor",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoTopologyClosedError": {
            "description": "An error generated when an attempt is made to operate on a\ndropped, or otherwise unavailable, database.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoTransactionError": {
            "description": "An error generated when the user makes a mistake in the usage of transactions.\n(e.g. attempting to commit a transaction with a readPreference other than primary)",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoUnexpectedServerResponseError": {
            "description": "An error generated when a **parsable** unexpected response comes from the server.\nThis is generally an error where the driver in a state expecting a certain behavior to occur in\nthe next message from MongoDB but it receives something else.\nThis error **does not** represent an issue with wire message formatting.\n\n#### Example\nWhen an operation fails, it is the driver's job to retry it. It must perform serverSelection\nagain to make sure that it attempts the operation against a server in a good state. If server\nselection returns a server that does not support retryable operations, this error is used.\nThis scenario is unlikely as retryable support would also have been determined on the first attempt\nbut it is possible the state change could report a selectable server that does not support retries.",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                }
            },
            "type": "object"
        },
        "MongoWriteConcernError": {
            "description": "An error thrown when the server reports a writeConcernError",
            "properties": {
                "cause": {
                    "$ref": "#/definitions/Error_1"
                },
                "code": {
                    "description": "This is a number in MongoServerError and a string in MongoDriverError",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "codeName": {
                    "type": "string"
                },
                "connectionGeneration": {
                    "type": "number"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document"
                },
                "errmsg": {
                    "description": "Legacy name for server error responses",
                    "type": "string"
                },
                "errorLabels": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ok": {
                    "type": "number"
                },
                "result": {
                    "$ref": "#/definitions/Document",
                    "description": "The result document (provided if ok: 1)"
                },
                "stack": {
                    "type": "string"
                },
                "topologyVersion": {
                    "$ref": "#/definitions/TopologyVersion"
                },
                "writeConcernError": {
                    "$ref": "#/definitions/Document"
                }
            },
            "type": "object"
        },
        "MongooseError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "description": "The type of error. \"MongooseError\" for generic errors.",
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MongooseQueryOptions<any>": {
            "properties": {
                "lean": {
                    "description": "If truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document."
                },
                "populate": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/PopulateOptions"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/PopulateOptions"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "sanitizeFilter": {
                    "description": "Set to `true` to automatically sanitize potentially unsafe query filters by stripping out query selectors that\naren't explicitly allowed using `mongoose.trusted()`.",
                    "type": "boolean"
                },
                "sanitizeProjection": {
                    "type": "boolean"
                },
                "strict": {
                    "description": "overwrites the schema's strict mode option",
                    "type": [
                        "string",
                        "boolean"
                    ]
                }
            },
            "type": "object"
        },
        "NativeDate": {
            "properties": {
                "getVarDate": {
                    "type": "object"
                }
            },
            "type": "object"
        },
        "NativeError": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "NodeJS.EventEmitter": {
            "type": "object"
        },
        "Number": {
            "type": "object"
        },
        "NumberConstructor": {
            "properties": {
                "EPSILON": {
                    "type": "number"
                },
                "MAX_SAFE_INTEGER": {
                    "type": "number"
                },
                "MAX_VALUE": {
                    "type": "number"
                },
                "MIN_SAFE_INTEGER": {
                    "type": "number"
                },
                "MIN_VALUE": {
                    "type": "number"
                },
                "NEGATIVE_INFINITY": {
                    "type": "number"
                },
                "NaN": {
                    "type": "number"
                },
                "POSITIVE_INFINITY": {
                    "type": "number"
                },
                "prototype": {
                    "$ref": "#/definitions/Number"
                }
            },
            "type": "object"
        },
        "ObjectID": {
            "description": "A class representation of the BSON ObjectId type.",
            "properties": {
                "_bsontype": {
                    "const": "ObjectID",
                    "type": "string"
                },
                "_id": {
                    "$ref": "#/definitions/ObjectID",
                    "description": "Mongoose automatically adds a conveniency \"_id\" getter on the base ObjectId class"
                },
                "generationTime": {
                    "description": "The generation time of this ObjectId instance",
                    "type": "number"
                },
                "id": {
                    "additionalProperties": false,
                    "description": "The ObjectId bytes",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Omit<ConnectionPoolOptions,\"credentials\">": {
            "properties": {
                "ALPNProtocols": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "additionalProperties": false,
                                "patternProperties": {
                                    "^[0-9]+$": {
                                        "type": "number"
                                    }
                                },
                                "properties": {
                                    "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                    },
                                    "__@toStringTag@1754": {
                                        "const": "Uint8Array",
                                        "type": "string"
                                    },
                                    "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                    },
                                    "byteLength": {
                                        "type": "number"
                                    },
                                    "byteOffset": {
                                        "type": "number"
                                    },
                                    "length": {
                                        "type": "number"
                                    }
                                },
                                "type": "object"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "An array of strings or a Buffer naming possible ALPN protocols.\n(Protocols should be ordered by their priority.)"
                },
                "autoEncrypter": {
                    "$ref": "#/definitions/AutoEncrypter"
                },
                "ca": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Optionally override the trusted CA certificates. Default is to trust\nthe well-known CAs curated by Mozilla. Mozilla's CAs are completely\nreplaced when CAs are explicitly specified using this option."
                },
                "cancellationToken": {
                    "$ref": "#/definitions/CancellationToken"
                },
                "cert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Cert chains in PEM format. One cert chain should be provided per\nprivate key. Each cert chain should consist of the PEM formatted\ncertificate for a provided private key, followed by the PEM\nformatted intermediate certificates (if any), in order, and not\nincluding the root CA (the root CA must be pre-known to the peer,\nsee ca). When providing multiple cert chains, they do not have to\nbe in the same order as their private keys in key. If the\nintermediate certificates are not provided, the peer will not be\nable to validate the certificate, and the handshake will fail."
                },
                "checkServerIdentity": {
                    "description": "Verifies the certificate `cert` is issued to `hostname`.\n\nReturns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on\nfailure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type).\n\nThis function can be overwritten by providing alternative function as part of\nthe `options.checkServerIdentity` option passed to `tls.connect()`. The\noverwriting function can call `tls.checkServerIdentity()` of course, to augment\nthe checks done with additional verification.\n\nThis function is only called if the certificate passed all other checks, such as\nbeing issued by trusted CA (`options.ca`).",
                    "type": "object"
                },
                "ciphers": {
                    "description": "Cipher suite specification, replacing the default. For more\ninformation, see modifying the default cipher suite. Permitted\nciphers can be obtained via tls.getCiphers(). Cipher names must be\nuppercased in order for OpenSSL to accept them.",
                    "type": "string"
                },
                "compressors": {
                    "items": {
                        "enum": [
                            "none",
                            "snappy",
                            "zlib",
                            "zstd"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "connectTimeoutMS": {
                    "type": "number"
                },
                "crl": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                },
                "ecdhCurve": {
                    "description": "A string describing a named curve or a colon separated list of curve\nNIDs or names, for example P-521:P-384:P-256, to use for ECDH key\nagreement. Set to auto to select the curve automatically. Use\ncrypto.getCurves() to obtain a list of available curve names. On\nrecent releases, openssl ecparam -list_curves will also display the\nname and description of each available elliptic curve. Default:\ntls.DEFAULT_ECDH_CURVE.",
                    "type": "string"
                },
                "family": {
                    "type": "number"
                },
                "hints": {
                    "type": "number"
                },
                "hostAddress": {
                    "$ref": "#/definitions/HostAddress"
                },
                "keepAlive": {
                    "type": "boolean"
                },
                "keepAliveInitialDelay": {
                    "type": "number"
                },
                "key": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/KeyObject"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format. PEM allows the option of private keys\nbeing encrypted. Encrypted keys will be decrypted with\noptions.passphrase. Multiple keys using different algorithms can be\nprovided either as an array of unencrypted key strings or buffers,\nor an array of objects in the form {pem: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted keys will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "loadBalanced": {
                    "description": "If we are in load balancer mode.",
                    "type": "boolean"
                },
                "localAddress": {
                    "type": "string"
                },
                "localPort": {
                    "type": "number"
                },
                "logicalSessionTimeoutMinutes": {
                    "type": "number"
                },
                "lookup": {
                    "type": "object"
                },
                "maxConnecting": {
                    "description": "The maximum number of connections that may be in the process of being established concurrently by the connection pool.",
                    "type": "number"
                },
                "maxIdleTimeMS": {
                    "description": "The maximum amount of time a connection should remain idle in the connection pool before being marked idle.",
                    "type": "number"
                },
                "maxPoolSize": {
                    "description": "The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections.",
                    "type": "number"
                },
                "metadata": {
                    "$ref": "#/definitions/ClientMetadata"
                },
                "minDHSize": {
                    "type": "number"
                },
                "minPoolSize": {
                    "description": "The minimum number of connections that MUST exist at any moment in a single connection pool.",
                    "type": "number"
                },
                "monitorCommands": {
                    "type": "boolean"
                },
                "noDelay": {
                    "type": "boolean"
                },
                "passphrase": {
                    "description": "Shared passphrase used for a single private key and/or a PFX.",
                    "type": "string"
                },
                "pfx": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@1754": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/PxfObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an\nalternative to providing key and cert individually. PFX is usually\nencrypted, if it is, passphrase will be used to decrypt it. Multiple\nPFX can be provided either as an array of unencrypted PFX buffers,\nor an array of objects in the form {buf: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted PFX will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "proxyHost": {
                    "type": "string"
                },
                "proxyPassword": {
                    "type": "string"
                },
                "proxyPort": {
                    "type": "number"
                },
                "proxyUsername": {
                    "type": "string"
                },
                "rejectUnauthorized": {
                    "default": true,
                    "description": "If true the server will reject any connection which is not\nauthorized with the list of supplied CAs. This option only has an\neffect if requestCert is true.",
                    "type": "boolean"
                },
                "secureContext": {
                    "$ref": "#/definitions/SecureContext",
                    "description": "An optional TLS context object from tls.createSecureContext()"
                },
                "secureProtocol": {
                    "description": "Legacy mechanism to select the TLS protocol version to use, it does\nnot support independent control of the minimum and maximum version,\nand does not support limiting the protocol to TLSv1.3. Use\nminVersion and maxVersion instead. The possible values are listed as\nSSL_METHODS, use the function names as strings. For example, use\n'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\nany TLS protocol version up to TLSv1.3. It is not recommended to use\nTLS versions less than 1.2, but it may be required for\ninteroperability. Default: none, see minVersion.",
                    "type": "string"
                },
                "serverApi": {
                    "$ref": "#/definitions/ServerApi"
                },
                "servername": {
                    "type": "string"
                },
                "session": {
                    "additionalProperties": false,
                    "description": "An optional Buffer instance containing a TLS session.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "socketTimeoutMS": {
                    "type": "number"
                },
                "tls": {
                    "type": "boolean"
                },
                "waitQueueTimeoutMS": {
                    "description": "The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit.",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "OneOrMore<WriteError>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/WriteError"
                },
                {
                    "items": {
                        "$ref": "#/definitions/WriteError"
                    },
                    "type": "array"
                }
            ]
        },
        "OrderedBulkOperation": {
            "properties": {
                "batches": {
                    "items": {
                        "$ref": "#/definitions/Batch<Document>"
                    },
                    "type": "array"
                },
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "isOrdered": {
                    "type": "boolean"
                },
                "operationId": {
                    "type": "number"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                }
            },
            "type": "object"
        },
        "PassThrough": {
            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams.",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "PkFactory": {
            "type": "object"
        },
        "PopulateOptions": {
            "properties": {
                "foreignField": {
                    "description": "Overwrite the schema-level foreign field to populate on if this is a populated virtual.",
                    "type": "string"
                },
                "justOne": {
                    "description": "If true Mongoose will always set `path` to a document, or `null` if no document was found.\nIf false Mongoose will always set `path` to an array, which will be empty if no documents are found.\nInferred from schema by default.",
                    "type": "boolean"
                },
                "localField": {
                    "description": "Overwrite the schema-level local field to populate on if this is a populated virtual.",
                    "type": "string"
                },
                "match": {
                    "description": "query conditions to match"
                },
                "model": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Model<any,{},{},{},any>"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "optional model to use for population"
                },
                "options": {
                    "$ref": "#/definitions/QueryOptions<unknown>",
                    "description": "optional query options like sort, limit, etc"
                },
                "path": {
                    "description": "space delimited path(s) to populate",
                    "type": "string"
                },
                "perDocumentLimit": {
                    "description": "correct limit on populated array",
                    "type": "number"
                },
                "populate": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/PopulateOptions"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/PopulateOptions"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "deep populate"
                },
                "select": {
                    "description": "fields to select"
                },
                "strictPopulate": {
                    "description": "optional boolean, set to `false` to allow populating paths that aren't in the schema",
                    "type": "boolean"
                },
                "transform": {
                    "description": "transform function to call on every populated doc",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Promise": {
            "description": "Global promise store allowing user-provided promises",
            "type": "object"
        },
        "ProxyOptions": {
            "properties": {
                "proxyHost": {
                    "type": "string"
                },
                "proxyPassword": {
                    "type": "string"
                },
                "proxyPort": {
                    "type": "number"
                },
                "proxyUsername": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "PxfObject": {
            "properties": {
                "buf": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@1754": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain."
                },
                "passphrase": {
                    "description": "Optional passphrase.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Query<any,any,any,any>": {
            "properties": {
                "_mongooseOptions": {
                    "$ref": "#/definitions/MongooseQueryOptions<any>"
                },
                "catch": {
                    "description": "Executes the query returning a `Promise` which will be\nresolved with either the doc(s) or rejected with the error.\nLike `.then()`, but only takes a rejection handler.",
                    "type": "object"
                },
                "model": {
                    "$ref": "#/definitions/Model<any,{},{},{},any>",
                    "description": "The model this query was created from"
                },
                "then": {
                    "description": "Executes the query returning a `Promise` which will be\nresolved with either the doc(s) or rejected with the error.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "QueryOptions<unknown>": {
            "additionalProperties": {},
            "properties": {
                "arrayFilters": {
                    "items": {
                        "additionalProperties": {},
                        "type": "object"
                    },
                    "type": "array"
                },
                "batchSize": {
                    "type": "number"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions"
                },
                "comment": {},
                "context": {
                    "type": "string"
                },
                "explain": {
                    "description": "For backwards compatibility, true is interpreted as \"allPlansExecution\"\nand false as \"queryPlanner\". Prior to server version 3.6, aggregate()\nignores the verbosity parameter and executes in \"queryPlanner\".",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fields": {},
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "lean": {
                    "description": "If truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document."
                },
                "limit": {
                    "type": "number"
                },
                "maxTimeMS": {
                    "type": "number"
                },
                "maxscan": {
                    "type": "number"
                },
                "multi": {
                    "type": "boolean"
                },
                "multipleCastError": {
                    "type": "boolean"
                },
                "new": {
                    "description": "By default, `findOneAndUpdate()` returns the document as it was **before**\n`update` was applied. If you set `new: true`, `findOneAndUpdate()` will\ninstead give you the object after `update` was applied.",
                    "type": "boolean"
                },
                "overwrite": {
                    "type": "boolean"
                },
                "overwriteDiscriminatorKey": {
                    "type": "boolean"
                },
                "populate": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/PopulateOptions"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/PopulateOptions"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "projection": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnyObject"
                        },
                        {
                            "$ref": "#/definitions/{}_5"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "rawResult": {
                    "description": "if true, returns the raw result from the MongoDB driver",
                    "type": "boolean"
                },
                "readPreference": {
                    "type": "string"
                },
                "returnDocument": {
                    "description": "Another alias for the `new` option. `returnOriginal` is deprecated so this should be used.",
                    "enum": [
                        "after",
                        "before"
                    ],
                    "type": "string"
                },
                "returnOriginal": {
                    "description": "An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.",
                    "type": "boolean"
                },
                "runValidators": {
                    "type": "boolean"
                },
                "sanitizeFilter": {
                    "description": "Set to `true` to automatically sanitize potentially unsafe query filters by stripping out query selectors that\naren't explicitly allowed using `mongoose.trusted()`.",
                    "type": "boolean"
                },
                "sanitizeProjection": {
                    "type": "boolean"
                },
                "session": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ClientSession"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "setDefaultsOnInsert": {
                    "type": "boolean"
                },
                "skip": {
                    "type": "number"
                },
                "snapshot": {},
                "sort": {},
                "strict": {
                    "description": "overwrites the schema's strict mode option",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "strictQuery": {
                    "description": "equal to `strict` by default, may be `false`, `true`, or `'throw'`. Sets the default\n[strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.",
                    "enum": [
                        false,
                        "throw",
                        true
                    ]
                },
                "tailable": {
                    "type": "number"
                },
                "timestamps": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/QueryTimestampsConfig"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "If set to `false` and schema-level timestamps are enabled,\nskip timestamps for this update. Note that this allows you to overwrite\ntimestamps. Does nothing if schema-level timestamps are not set."
                },
                "upsert": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "A MongoDB WriteConcern, which describes the level of acknowledgement\nrequested from MongoDB for write operations."
                }
            },
            "type": "object"
        },
        "QueryTimestampsConfig": {
            "properties": {
                "createdAt": {
                    "type": "boolean"
                },
                "updatedAt": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ReadConcern": {
            "description": "The MongoDB ReadConcern, which allows for control of the consistency and isolation properties\nof the data read from replica sets and replica set shards.",
            "properties": {
                "level": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ReadConcernLevel": {
            "enum": [
                "available",
                "linearizable",
                "local",
                "majority",
                "snapshot"
            ],
            "type": "string"
        },
        "ReadPreference": {
            "description": "The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\nused to construct connections.",
            "properties": {
                "hedge": {
                    "$ref": "#/definitions/HedgeOptions"
                },
                "maxStalenessSeconds": {
                    "type": "number"
                },
                "minWireVersion": {
                    "type": "number"
                },
                "mode": {
                    "$ref": "#/definitions/ReadPreferenceMode"
                },
                "preference": {
                    "$ref": "#/definitions/ReadPreferenceMode"
                },
                "tags": {
                    "items": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ReadPreferenceMode": {
            "enum": [
                "nearest",
                "primary",
                "primaryPreferred",
                "secondary",
                "secondaryPreferred"
            ],
            "type": "string"
        },
        "Readable": {
            "properties": {
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Record<never,never>": {
            "type": "object"
        },
        "Record<string,MongoServerError>": {
            "type": "object"
        },
        "Record<string,any>": {
            "type": "object"
        },
        "Record<string,number>": {
            "type": "object"
        },
        "Record<string,unknown>": {
            "type": "object"
        },
        "RegExp": {
            "properties": {
                "dotAll": {
                    "type": "boolean"
                },
                "flags": {
                    "type": "string"
                },
                "global": {
                    "type": "boolean"
                },
                "ignoreCase": {
                    "type": "boolean"
                },
                "lastIndex": {
                    "type": "number"
                },
                "multiline": {
                    "type": "boolean"
                },
                "source": {
                    "type": "string"
                },
                "sticky": {
                    "type": "boolean"
                },
                "unicode": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Schema.Types.Array": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "caster": {
                    "$ref": "#/definitions/SchemaType<any,any>",
                    "description": "The schematype embedded in this array"
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Boolean": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Buffer": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Date": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Decimal128": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.DocumentArray": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "caster": {
                    "description": "The constructor used for subdocuments in this array",
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Schema.Types.Subdocument"
                        },
                        "schemaName": {
                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema used for documents in this array"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Map": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Mixed": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Number": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.ObjectId": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.String": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.Subdocument": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The document's schema"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema.Types.UUID": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>": {
            "properties": {
                "childSchemas": {
                    "description": "Array of child schemas (from document arrays and single nested subdocs)\nand their corresponding compiled models. Each element of the array is\nan object with 2 properties: `schema` and `model`.",
                    "items": {
                        "properties": {
                            "model": {},
                            "schema": {
                                "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                            }
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "discriminators": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                    },
                    "description": "Object containing discriminators defined on this schema",
                    "type": "object"
                },
                "methods": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{}"
                        },
                        {
                            "$ref": "#/definitions/AnyObject"
                        }
                    ],
                    "description": "Object of currently defined methods on this schema."
                },
                "obj": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        }
                    ],
                    "description": "The original object passed to the schema constructor"
                },
                "paths": {
                    "additionalProperties": {
                        "$ref": "#/definitions/SchemaType<any,any>"
                    },
                    "description": "Lists all paths and their type in the schema.",
                    "type": "object"
                },
                "query": {
                    "description": "Object of currently defined query helpers on this schema.",
                    "properties": {},
                    "type": "object"
                },
                "statics": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{}_4"
                        },
                        {
                            "additionalProperties": {
                                "type": "object"
                            },
                            "type": "object"
                        }
                    ],
                    "description": "Object of currently defined statics on this schema."
                },
                "virtuals": {
                    "description": "Object of currently defined virtuals on this schema",
                    "properties": {},
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Schema<any,any,any,any,any,any,any,any>": {
            "properties": {
                "childSchemas": {
                    "description": "Array of child schemas (from document arrays and single nested subdocs)\nand their corresponding compiled models. Each element of the array is\nan object with 2 properties: `schema` and `model`.",
                    "items": {
                        "properties": {
                            "model": {},
                            "schema": {
                                "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                            }
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "discriminators": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                    },
                    "description": "Object containing discriminators defined on this schema",
                    "type": "object"
                },
                "methods": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{[x:string]:any;}_2"
                        },
                        {
                            "$ref": "#/definitions/AnyObject"
                        }
                    ],
                    "description": "Object of currently defined methods on this schema."
                },
                "obj": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        }
                    ],
                    "description": "The original object passed to the schema constructor"
                },
                "paths": {
                    "additionalProperties": {
                        "$ref": "#/definitions/SchemaType<any,any>"
                    },
                    "description": "Lists all paths and their type in the schema.",
                    "type": "object"
                },
                "query": {
                    "description": "Object of currently defined query helpers on this schema."
                },
                "statics": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{[x:string]:any;}_3"
                        },
                        {
                            "additionalProperties": {
                                "type": "object"
                            },
                            "type": "object"
                        }
                    ],
                    "description": "Object of currently defined statics on this schema."
                },
                "virtuals": {
                    "description": "Object of currently defined virtuals on this schema"
                }
            },
            "type": "object"
        },
        "Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>": {
            "properties": {
                "childSchemas": {
                    "description": "Array of child schemas (from document arrays and single nested subdocs)\nand their corresponding compiled models. Each element of the array is\nan object with 2 properties: `schema` and `model`.",
                    "items": {
                        "properties": {
                            "model": {},
                            "schema": {
                                "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                            }
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "discriminators": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                    },
                    "description": "Object containing discriminators defined on this schema",
                    "type": "object"
                },
                "methods": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{[x:string]:any;}"
                        },
                        {
                            "$ref": "#/definitions/AnyObject"
                        }
                    ],
                    "description": "Object of currently defined methods on this schema."
                },
                "obj": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        }
                    ],
                    "description": "The original object passed to the schema constructor"
                },
                "paths": {
                    "additionalProperties": {
                        "$ref": "#/definitions/SchemaType<any,any>"
                    },
                    "description": "Lists all paths and their type in the schema.",
                    "type": "object"
                },
                "query": {
                    "description": "Object of currently defined query helpers on this schema.",
                    "properties": {},
                    "type": "object"
                },
                "statics": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{}_2"
                        },
                        {
                            "additionalProperties": {
                                "type": "object"
                            },
                            "type": "object"
                        }
                    ],
                    "description": "Object of currently defined statics on this schema."
                },
                "virtuals": {
                    "description": "Object of currently defined virtuals on this schema",
                    "properties": {},
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1": {
            "properties": {
                "childSchemas": {
                    "description": "Array of child schemas (from document arrays and single nested subdocs)\nand their corresponding compiled models. Each element of the array is\nan object with 2 properties: `schema` and `model`.",
                    "items": {
                        "properties": {
                            "model": {},
                            "schema": {
                                "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                            }
                        },
                        "type": "object"
                    },
                    "type": "array"
                },
                "discriminators": {
                    "additionalProperties": {
                        "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                    },
                    "description": "Object containing discriminators defined on this schema",
                    "type": "object"
                },
                "methods": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{[x:string]:any;}_1"
                        },
                        {
                            "$ref": "#/definitions/AnyObject"
                        }
                    ],
                    "description": "Object of currently defined methods on this schema."
                },
                "obj": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        }
                    ],
                    "description": "The original object passed to the schema constructor"
                },
                "paths": {
                    "additionalProperties": {
                        "$ref": "#/definitions/SchemaType<any,any>"
                    },
                    "description": "Lists all paths and their type in the schema.",
                    "type": "object"
                },
                "query": {
                    "description": "Object of currently defined query helpers on this schema.",
                    "properties": {},
                    "type": "object"
                },
                "statics": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/{}_3"
                        },
                        {
                            "additionalProperties": {
                                "type": "object"
                            },
                            "type": "object"
                        }
                    ],
                    "description": "Object of currently defined statics on this schema."
                },
                "virtuals": {
                    "description": "Object of currently defined virtuals on this schema",
                    "properties": {},
                    "type": "object"
                }
            },
            "type": "object"
        },
        "SchemaDefinitionProperty<undefined>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/Function"
                },
                {
                    "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                },
                {
                    "$ref": "#/definitions/typeofSchemaType"
                },
                {
                    "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                },
                {
                    "items": {
                        "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1"
                    },
                    "type": "array"
                },
                {
                    "items": {
                        "$ref": "#/definitions/Function"
                    },
                    "type": "array"
                },
                {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Schema.Types.Mixed"
                        },
                        "schemaName": {
                            "const": "Mixed",
                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                {
                    "$ref": "#/definitions/MixedSchemaTypeOptions"
                },
                {
                    "$ref": "#/definitions/SchemaTypeOptions<any>"
                },
                {
                    "items": {
                        "$ref": "#/definitions/SchemaTypeOptions<any>_2"
                    },
                    "type": "array"
                },
                {
                    "items": {
                        "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                    },
                    "type": "array"
                },
                {
                    "type": "string"
                }
            ]
        },
        "SchemaType<any,any>": {
            "properties": {
                "OptionsConstructor": {
                    "$ref": "#/definitions/SchemaTypeOptions<any>",
                    "description": "The class that Mongoose uses internally to instantiate this SchemaType's `options` property."
                },
                "defaultOptions": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Default options for this SchemaType"
                },
                "instance": {
                    "description": "String representation of what type this is, like 'ObjectID' or 'Number'",
                    "type": "string"
                },
                "isRequired": {
                    "description": "True if this SchemaType has a required validator. False otherwise.",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/AnyObject",
                    "description": "The options this SchemaType was instantiated with"
                },
                "path": {
                    "description": "The path to this SchemaType in a Schema.",
                    "type": "string"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The schema this SchemaType instance is part of"
                },
                "validators": {
                    "description": "The validators that Mongoose should run to validate properties at this SchemaType's path.",
                    "items": {
                        "$ref": "#/definitions/Validator"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "SchemaTypeOptions<any>": {
            "additionalProperties": {},
            "properties": {
                "_id": {
                    "description": "If set, overrides the child schema's `_id` option. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "alias": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Defines a virtual with the given name that gets/sets this path."
                },
                "auto": {
                    "description": "If true, uses Mongoose's default `_id` settings. Only allowed for ObjectIds",
                    "type": "boolean"
                },
                "cast": {
                    "description": "Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.",
                    "type": "string"
                },
                "default": {
                    "description": "The default value for this path. If a function, Mongoose executes the function\nand uses the return value as the default."
                },
                "enum": {
                    "anyOf": [
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "message": {
                                    "type": "string"
                                },
                                "values": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        }
                                    ]
                                }
                            },
                            "type": "object"
                        },
                        {
                            "additionalProperties": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "object"
                        }
                    ],
                    "description": "array of allowed values for this path. Allowed for strings, numbers, and arrays of strings"
                },
                "excludeIndexes": {
                    "description": "If `true`, Mongoose will skip gathering indexes on subpaths. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "expires": {
                    "description": "Defines a TTL index on this path. Only allowed for dates.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "get": {
                    "description": "defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "immutable": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\ndisallow changes to this path once the document is saved to the database for the first time. Read more\nabout [immutability in Mongoose here](http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).",
                    "type": [
                        "object",
                        "boolean"
                    ]
                },
                "index": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/IndexOptions"
                        },
                        {
                            "enum": [
                                -1,
                                1,
                                "2d",
                                "2dsphere",
                                "asc",
                                "ascending",
                                "desc",
                                "descending",
                                false,
                                "geoHaystack",
                                "hashed",
                                "text",
                                true
                            ]
                        }
                    ],
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild an index on this path when the model is compiled."
                },
                "lowercase": {
                    "description": "If truthy, Mongoose will add a custom setter that lowercases this string using JavaScript's built-in `String#toLowerCase()`.",
                    "type": "boolean"
                },
                "match": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        }
                    ],
                    "description": "Attaches a validator that succeeds if the data string matches the given regular expression, and fails otherwise."
                },
                "max": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The maximum value allowed for this path. Only allowed for numbers and dates."
                },
                "maxlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at most the given number."
                },
                "min": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The minimum value allowed for this path. Only allowed for numbers and dates."
                },
                "minlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at least the given number."
                },
                "of": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/typeofSchemaType"
                        },
                        {
                            "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Function"
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Mixed"
                                },
                                "schemaName": {
                                    "const": "Mixed",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/MixedSchemaTypeOptions"
                        },
                        {
                            "$ref": "#/definitions/SchemaTypeOptions<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Number"
                                },
                                "schemaName": {
                                    "const": "Number",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/StringConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.String"
                                },
                                "schemaName": {
                                    "const": "String",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/BooleanConstructor"
                        },
                        {
                            "properties": {
                                "convertToFalse": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `false`."
                                },
                                "convertToTrue": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `true`."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Boolean"
                                },
                                "schemaName": {
                                    "const": "Boolean",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/NativeDate"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Date"
                                },
                                "schemaName": {
                                    "const": "Date",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaTypeOptions<any>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                                    },
                                    {
                                        "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "If set, specifies the type of this map's values. Mongoose will cast this map's values to the given type."
                },
                "ref": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Model<any,{},{},{},any>"
                        },
                        {
                            "type": [
                                "string",
                                "object"
                            ]
                        }
                    ],
                    "description": "The model that `populate()` should use if populating this path."
                },
                "refPath": {
                    "description": "The path in the document that `populate()` should use to find the model\nto use.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "required": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "object"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "If true, attach a required validator to this path, which ensures this path\npath cannot be set to a nullish value. If a function, Mongoose calls the\nfunction and only checks for nullish values if the function returns a truthy value."
                },
                "select": {
                    "description": "Whether to include or exclude this path by default when loading documents\nusing `find()`, `findOne()`, etc.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "set": {
                    "description": "defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "sparse": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild a sparse index on this path.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "subtype": {
                    "description": "The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths",
                    "type": "number"
                },
                "text": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a text index on this path."
                },
                "transform": {
                    "description": "Define a transform function for this individual schema type.\nOnly called when calling `toJSON()` or `toObject()`.",
                    "type": "object"
                },
                "trim": {
                    "description": "If truthy, Mongoose will add a custom setter that removes leading and trailing whitespace using JavaScript's built-in `String#trim()`.",
                    "type": "boolean"
                },
                "type": {},
                "unique": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a unique index on this path when the\nmodel is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "uppercase": {
                    "description": "If truthy, Mongoose will add a custom setter that uppercases this string using JavaScript's built-in `String#toUpperCase()`.",
                    "type": "boolean"
                },
                "validate": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/Function"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/ValidateOpts<any>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValidateOpts<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html)."
                }
            },
            "type": "object"
        },
        "SchemaTypeOptions<any>_1": {
            "additionalProperties": {},
            "properties": {
                "_id": {
                    "description": "If set, overrides the child schema's `_id` option. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "alias": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Defines a virtual with the given name that gets/sets this path."
                },
                "auto": {
                    "description": "If true, uses Mongoose's default `_id` settings. Only allowed for ObjectIds",
                    "type": "boolean"
                },
                "cast": {
                    "description": "Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.",
                    "type": "string"
                },
                "default": {
                    "description": "The default value for this path. If a function, Mongoose executes the function\nand uses the return value as the default."
                },
                "enum": {
                    "anyOf": [
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "message": {
                                    "type": "string"
                                },
                                "values": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        }
                                    ]
                                }
                            },
                            "type": "object"
                        },
                        {
                            "additionalProperties": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "object"
                        }
                    ],
                    "description": "array of allowed values for this path. Allowed for strings, numbers, and arrays of strings"
                },
                "excludeIndexes": {
                    "description": "If `true`, Mongoose will skip gathering indexes on subpaths. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "expires": {
                    "description": "Defines a TTL index on this path. Only allowed for dates.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "get": {
                    "description": "defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "immutable": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\ndisallow changes to this path once the document is saved to the database for the first time. Read more\nabout [immutability in Mongoose here](http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).",
                    "type": [
                        "object",
                        "boolean"
                    ]
                },
                "index": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/IndexOptions"
                        },
                        {
                            "enum": [
                                -1,
                                1,
                                "2d",
                                "2dsphere",
                                "asc",
                                "ascending",
                                "desc",
                                "descending",
                                false,
                                "geoHaystack",
                                "hashed",
                                "text",
                                true
                            ]
                        }
                    ],
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild an index on this path when the model is compiled."
                },
                "lowercase": {
                    "description": "If truthy, Mongoose will add a custom setter that lowercases this string using JavaScript's built-in `String#toLowerCase()`.",
                    "type": "boolean"
                },
                "match": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        }
                    ],
                    "description": "Attaches a validator that succeeds if the data string matches the given regular expression, and fails otherwise."
                },
                "max": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The maximum value allowed for this path. Only allowed for numbers and dates."
                },
                "maxlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at most the given number."
                },
                "min": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The minimum value allowed for this path. Only allowed for numbers and dates."
                },
                "minlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at least the given number."
                },
                "of": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/typeofSchemaType"
                        },
                        {
                            "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Function"
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Mixed"
                                },
                                "schemaName": {
                                    "const": "Mixed",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/MixedSchemaTypeOptions"
                        },
                        {
                            "$ref": "#/definitions/SchemaTypeOptions<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Number"
                                },
                                "schemaName": {
                                    "const": "Number",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/StringConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.String"
                                },
                                "schemaName": {
                                    "const": "String",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/BooleanConstructor"
                        },
                        {
                            "properties": {
                                "convertToFalse": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `false`."
                                },
                                "convertToTrue": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `true`."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Boolean"
                                },
                                "schemaName": {
                                    "const": "Boolean",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/NativeDate"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Date"
                                },
                                "schemaName": {
                                    "const": "Date",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaTypeOptions<any>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                                    },
                                    {
                                        "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "If set, specifies the type of this map's values. Mongoose will cast this map's values to the given type."
                },
                "ref": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Model<any,{},{},{},any>"
                        },
                        {
                            "type": [
                                "string",
                                "object"
                            ]
                        }
                    ],
                    "description": "The model that `populate()` should use if populating this path."
                },
                "refPath": {
                    "description": "The path in the document that `populate()` should use to find the model\nto use.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "required": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "object"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "If true, attach a required validator to this path, which ensures this path\npath cannot be set to a nullish value. If a function, Mongoose calls the\nfunction and only checks for nullish values if the function returns a truthy value."
                },
                "select": {
                    "description": "Whether to include or exclude this path by default when loading documents\nusing `find()`, `findOne()`, etc.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "set": {
                    "description": "defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "sparse": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild a sparse index on this path.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "subtype": {
                    "description": "The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths",
                    "type": "number"
                },
                "text": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a text index on this path."
                },
                "transform": {
                    "description": "Define a transform function for this individual schema type.\nOnly called when calling `toJSON()` or `toObject()`.",
                    "type": "object"
                },
                "trim": {
                    "description": "If truthy, Mongoose will add a custom setter that removes leading and trailing whitespace using JavaScript's built-in `String#trim()`.",
                    "type": "boolean"
                },
                "type": {},
                "unique": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a unique index on this path when the\nmodel is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "uppercase": {
                    "description": "If truthy, Mongoose will add a custom setter that uppercases this string using JavaScript's built-in `String#toUpperCase()`.",
                    "type": "boolean"
                },
                "validate": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/Function"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/ValidateOpts<any>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValidateOpts<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html)."
                }
            },
            "type": "object"
        },
        "SchemaTypeOptions<any>_2": {
            "additionalProperties": {},
            "properties": {
                "_id": {
                    "description": "If set, overrides the child schema's `_id` option. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "alias": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Defines a virtual with the given name that gets/sets this path."
                },
                "auto": {
                    "description": "If true, uses Mongoose's default `_id` settings. Only allowed for ObjectIds",
                    "type": "boolean"
                },
                "cast": {
                    "description": "Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.",
                    "type": "string"
                },
                "default": {
                    "description": "The default value for this path. If a function, Mongoose executes the function\nand uses the return value as the default."
                },
                "enum": {
                    "anyOf": [
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "message": {
                                    "type": "string"
                                },
                                "values": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "items": {
                                                "type": [
                                                    "null",
                                                    "string",
                                                    "number"
                                                ]
                                            },
                                            "type": "array"
                                        }
                                    ]
                                }
                            },
                            "type": "object"
                        },
                        {
                            "additionalProperties": {
                                "type": [
                                    "null",
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "object"
                        }
                    ],
                    "description": "array of allowed values for this path. Allowed for strings, numbers, and arrays of strings"
                },
                "excludeIndexes": {
                    "description": "If `true`, Mongoose will skip gathering indexes on subpaths. Only allowed for subdocuments and subdocument arrays.",
                    "type": "boolean"
                },
                "expires": {
                    "description": "Defines a TTL index on this path. Only allowed for dates.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "get": {
                    "description": "defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "immutable": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\ndisallow changes to this path once the document is saved to the database for the first time. Read more\nabout [immutability in Mongoose here](http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).",
                    "type": [
                        "object",
                        "boolean"
                    ]
                },
                "index": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/IndexOptions"
                        },
                        {
                            "enum": [
                                -1,
                                1,
                                "2d",
                                "2dsphere",
                                "asc",
                                "ascending",
                                "desc",
                                "descending",
                                false,
                                "geoHaystack",
                                "hashed",
                                "text",
                                true
                            ]
                        }
                    ],
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild an index on this path when the model is compiled."
                },
                "lowercase": {
                    "description": "If truthy, Mongoose will add a custom setter that lowercases this string using JavaScript's built-in `String#toLowerCase()`.",
                    "type": "boolean"
                },
                "match": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        }
                    ],
                    "description": "Attaches a validator that succeeds if the data string matches the given regular expression, and fails otherwise."
                },
                "max": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The maximum value allowed for this path. Only allowed for numbers and dates."
                },
                "maxlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at most the given number."
                },
                "min": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NativeDate"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/NativeDate"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The minimum value allowed for this path. Only allowed for numbers and dates."
                },
                "minlength": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "If set, Mongoose will add a custom validator that ensures the given string's `length` is at least the given number."
                },
                "of": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                        },
                        {
                            "$ref": "#/definitions/typeofSchemaType"
                        },
                        {
                            "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Schema<any,any,any,{},{},{},DefaultSchemaOptions,{[x:string]:any;}>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Function"
                            },
                            "type": "array"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Mixed"
                                },
                                "schemaName": {
                                    "const": "Mixed",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/MixedSchemaTypeOptions"
                        },
                        {
                            "$ref": "#/definitions/SchemaTypeOptions<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Number"
                                },
                                "schemaName": {
                                    "const": "Number",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/StringConstructor"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.String"
                                },
                                "schemaName": {
                                    "const": "String",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/BooleanConstructor"
                        },
                        {
                            "properties": {
                                "convertToFalse": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `false`."
                                },
                                "convertToTrue": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `true`."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Boolean"
                                },
                                "schemaName": {
                                    "const": "Boolean",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/NativeDate"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Date"
                                },
                                "schemaName": {
                                    "const": "Date",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaTypeOptions<any>_1"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/{[path:string]:SchemaDefinitionProperty<undefined>;}"
                                    },
                                    {
                                        "$ref": "#/definitions/{[x:string]:SchemaDefinitionProperty<any>|undefined;}"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "If set, specifies the type of this map's values. Mongoose will cast this map's values to the given type."
                },
                "ref": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Model<any,{},{},{},any>"
                        },
                        {
                            "type": [
                                "string",
                                "object"
                            ]
                        }
                    ],
                    "description": "The model that `populate()` should use if populating this path."
                },
                "refPath": {
                    "description": "The path in the document that `populate()` should use to find the model\nto use.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "required": {
                    "anyOf": [
                        {
                            "items": [
                                {
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "type": "object"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "If true, attach a required validator to this path, which ensures this path\npath cannot be set to a nullish value. If a function, Mongoose calls the\nfunction and only checks for nullish values if the function returns a truthy value."
                },
                "select": {
                    "description": "Whether to include or exclude this path by default when loading documents\nusing `find()`, `findOne()`, etc.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "set": {
                    "description": "defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).",
                    "type": "object"
                },
                "sparse": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\nbuild a sparse index on this path.",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "subtype": {
                    "description": "The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths",
                    "type": "number"
                },
                "text": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a text index on this path."
                },
                "transform": {
                    "description": "Define a transform function for this individual schema type.\nOnly called when calling `toJSON()` or `toObject()`.",
                    "type": "object"
                },
                "trim": {
                    "description": "If truthy, Mongoose will add a custom setter that removes leading and trailing whitespace using JavaScript's built-in `String#trim()`.",
                    "type": "boolean"
                },
                "type": {},
                "unique": {
                    "description": "If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\nwill build a unique index on this path when the\nmodel is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "uppercase": {
                    "description": "If truthy, Mongoose will add a custom setter that uppercases this string using JavaScript's built-in `String#toUpperCase()`.",
                    "type": "boolean"
                },
                "validate": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/RegExp"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "items": [
                                {
                                    "$ref": "#/definitions/Function"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "maxItems": 2,
                            "minItems": 2,
                            "type": "array"
                        },
                        {
                            "$ref": "#/definitions/ValidateOpts<any>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValidateOpts<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/SchemaValidator<any>"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html)."
                }
            },
            "type": "object"
        },
        "SchemaValidator<Schema.Types.Mixed>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/Function"
                },
                {
                    "$ref": "#/definitions/RegExp"
                },
                {
                    "items": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "maxItems": 2,
                    "minItems": 2,
                    "type": "array"
                },
                {
                    "items": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "maxItems": 2,
                    "minItems": 2,
                    "type": "array"
                },
                {
                    "$ref": "#/definitions/ValidateOpts<Schema.Types.Mixed>"
                },
                {
                    "items": {
                        "$ref": "#/definitions/ValidateOpts<Schema.Types.Mixed>"
                    },
                    "type": "array"
                }
            ]
        },
        "SchemaValidator<any>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/Function"
                },
                {
                    "$ref": "#/definitions/RegExp"
                },
                {
                    "items": [
                        {
                            "$ref": "#/definitions/RegExp"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "maxItems": 2,
                    "minItems": 2,
                    "type": "array"
                },
                {
                    "items": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "maxItems": 2,
                    "minItems": 2,
                    "type": "array"
                },
                {
                    "$ref": "#/definitions/ValidateOpts<any>"
                },
                {
                    "items": {
                        "$ref": "#/definitions/ValidateOpts<any>"
                    },
                    "type": "array"
                }
            ]
        },
        "SecureContext": {
            "properties": {
                "context": {}
            },
            "type": "object"
        },
        "ServerApi": {
            "properties": {
                "deprecationErrors": {
                    "type": "boolean"
                },
                "strict": {
                    "type": "boolean"
                },
                "version": {
                    "const": "1",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ServerCapabilities": {
            "properties": {
                "commandsTakeCollation": {
                    "type": "boolean"
                },
                "commandsTakeWriteConcern": {
                    "type": "boolean"
                },
                "hasAggregationCursor": {
                    "type": "boolean"
                },
                "hasAuthCommands": {
                    "type": "boolean"
                },
                "hasListCollectionsCommand": {
                    "type": "boolean"
                },
                "hasListIndexesCommand": {
                    "type": "boolean"
                },
                "hasTextSearch": {
                    "type": "boolean"
                },
                "hasWriteCommands": {
                    "type": "boolean"
                },
                "maxWireVersion": {
                    "type": "number"
                },
                "minWireVersion": {
                    "type": "number"
                },
                "supportsSnapshotReads": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ServerClosedEvent": {
            "description": "Emitted when server is closed.",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the server",
                    "type": "string"
                },
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ServerDescription": {
            "description": "The client's view of a single server, based on the most recent hello outcome.\n\nInternal type, not meant to be directly instantiated",
            "properties": {
                "$clusterTime": {
                    "$ref": "#/definitions/ClusterTime"
                },
                "address": {
                    "type": "string"
                },
                "allHosts": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "arbiters": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "electionId": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ObjectID"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "error": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/MongoError"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "host": {
                    "type": "string"
                },
                "hostAddress": {
                    "$ref": "#/definitions/HostAddress"
                },
                "hosts": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "isDataBearing": {
                    "description": "Is this server data bearing",
                    "type": "boolean"
                },
                "isReadable": {
                    "description": "Is this server available for reads",
                    "type": "boolean"
                },
                "isWritable": {
                    "description": "Is this server available for writes",
                    "type": "boolean"
                },
                "lastUpdateTime": {
                    "type": "number"
                },
                "lastWriteDate": {
                    "type": "number"
                },
                "logicalSessionTimeoutMinutes": {
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "maxWireVersion": {
                    "type": "number"
                },
                "me": {
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "minWireVersion": {
                    "type": "number"
                },
                "passives": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "port": {
                    "type": "number"
                },
                "primary": {
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "roundTripTime": {
                    "type": "number"
                },
                "setName": {
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "setVersion": {
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "tags": {
                    "additionalProperties": {
                        "type": "string"
                    },
                    "type": "object"
                },
                "topologyVersion": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TopologyVersion"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "type": {
                    "$ref": "#/definitions/ServerType"
                }
            },
            "type": "object"
        },
        "ServerDescriptionChangedEvent": {
            "description": "Emitted when server description changes, but does NOT include changes to the RTT.",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the server",
                    "type": "string"
                },
                "newDescription": {
                    "$ref": "#/definitions/ServerDescription",
                    "description": "The new server description"
                },
                "previousDescription": {
                    "$ref": "#/definitions/ServerDescription",
                    "description": "The previous server description"
                },
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ServerHeartbeatFailedEvent": {
            "description": "Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.",
            "properties": {
                "connectionId": {
                    "description": "The connection id for the command",
                    "type": "string"
                },
                "duration": {
                    "description": "The execution time of the event in ms",
                    "type": "number"
                },
                "failure": {
                    "$ref": "#/definitions/Error_1",
                    "description": "The command failure"
                }
            },
            "type": "object"
        },
        "ServerHeartbeatStartedEvent": {
            "description": "Emitted when the server monitors hello command is started - immediately before\nthe hello command is serialized into raw BSON and written to the socket.",
            "properties": {
                "connectionId": {
                    "description": "The connection id for the command",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ServerHeartbeatSucceededEvent": {
            "description": "Emitted when the server monitors hello succeeds.",
            "properties": {
                "connectionId": {
                    "description": "The connection id for the command",
                    "type": "string"
                },
                "duration": {
                    "description": "The execution time of the event in ms",
                    "type": "number"
                },
                "reply": {
                    "$ref": "#/definitions/Document",
                    "description": "The command reply"
                }
            },
            "type": "object"
        },
        "ServerOpeningEvent": {
            "description": "Emitted when server is initialized.",
            "properties": {
                "address": {
                    "description": "The address (host/port pair) of the server",
                    "type": "string"
                },
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ServerSession": {
            "description": "Reflects the existence of a session on the server. Can be reused by the session pool.\nWARNING: not meant to be instantiated directly. For internal use only.",
            "properties": {
                "id": {
                    "properties": {
                        "id": {
                            "$ref": "#/definitions/Binary"
                        }
                    },
                    "type": "object"
                },
                "isDirty": {
                    "type": "boolean"
                },
                "lastUse": {
                    "type": "number"
                },
                "txnNumber": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ServerType": {
            "description": "An enumeration of server types we know about",
            "enum": [
                "LoadBalancer",
                "Mongos",
                "PossiblePrimary",
                "RSArbiter",
                "RSGhost",
                "RSOther",
                "RSPrimary",
                "RSSecondary",
                "Standalone",
                "Unknown"
            ],
            "type": "string"
        },
        "Set<any>": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "SharedArrayBuffer": {
            "properties": {
                "__@species@1110": {
                    "$ref": "#/definitions/SharedArrayBuffer"
                },
                "__@toStringTag@1754": {
                    "const": "SharedArrayBuffer",
                    "type": "string"
                },
                "byteLength": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Stream": {
            "type": "object"
        },
        "StreamDescription": {
            "properties": {
                "__nodejs_mock_server__": {
                    "type": "boolean"
                },
                "address": {
                    "type": "string"
                },
                "compressor": {
                    "enum": [
                        "none",
                        "snappy",
                        "zlib",
                        "zstd"
                    ],
                    "type": "string"
                },
                "compressors": {
                    "items": {
                        "enum": [
                            "none",
                            "snappy",
                            "zlib",
                            "zstd"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "logicalSessionTimeoutMinutes": {
                    "type": "number"
                },
                "maxBsonObjectSize": {
                    "type": "number"
                },
                "maxMessageSizeBytes": {
                    "type": "number"
                },
                "maxWireVersion": {
                    "type": "number"
                },
                "maxWriteBatchSize": {
                    "type": "number"
                },
                "minWireVersion": {
                    "type": "number"
                },
                "type": {
                    "type": "string"
                },
                "zlibCompressionLevel": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "StringConstructor": {
            "properties": {
                "prototype": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "string"
                        }
                    },
                    "properties": {
                        "america": {
                            "type": "string"
                        },
                        "bgBlack": {
                            "type": "string"
                        },
                        "bgBlue": {
                            "type": "string"
                        },
                        "bgCyan": {
                            "type": "string"
                        },
                        "bgGreen": {
                            "type": "string"
                        },
                        "bgMagenta": {
                            "type": "string"
                        },
                        "bgRed": {
                            "type": "string"
                        },
                        "bgWhite": {
                            "type": "string"
                        },
                        "bgYellow": {
                            "type": "string"
                        },
                        "black": {
                            "type": "string"
                        },
                        "blue": {
                            "type": "string"
                        },
                        "cyan": {
                            "type": "string"
                        },
                        "dim": {
                            "type": "string"
                        },
                        "gray": {
                            "type": "string"
                        },
                        "green": {
                            "type": "string"
                        },
                        "grey": {
                            "type": "string"
                        },
                        "hidden": {
                            "type": "string"
                        },
                        "inverse": {
                            "type": "string"
                        },
                        "italic": {
                            "type": "string"
                        },
                        "length": {
                            "type": "number"
                        },
                        "magenta": {
                            "type": "string"
                        },
                        "rainbow": {
                            "type": "string"
                        },
                        "random": {
                            "type": "string"
                        },
                        "red": {
                            "type": "string"
                        },
                        "reset": {
                            "type": "string"
                        },
                        "strikethrough": {
                            "type": "string"
                        },
                        "strip": {
                            "type": "string"
                        },
                        "stripColors": {
                            "type": "string"
                        },
                        "trap": {
                            "type": "string"
                        },
                        "underline": {
                            "type": "string"
                        },
                        "white": {
                            "type": "string"
                        },
                        "yellow": {
                            "type": "string"
                        },
                        "zalgo": {
                            "type": "string"
                        },
                        "zebra": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Timestamp": {
            "properties": {
                "__isLong__": {
                    "const": true,
                    "type": "boolean"
                },
                "_bsontype": {
                    "const": "Timestamp",
                    "type": "string"
                },
                "add": {
                    "description": "Returns the sum of this and the specified Long.",
                    "type": "object"
                },
                "and": {
                    "description": "Returns the sum of this and the specified Long.",
                    "type": "object"
                },
                "comp": {
                    "description": "This is an alias of {@link Long.compare}",
                    "type": "object"
                },
                "compare": {
                    "description": "Compares this Long's value with the specified's.",
                    "type": "object"
                },
                "div": {
                    "description": "This is an alias of {@link Long.divide}",
                    "type": "object"
                },
                "divide": {
                    "description": "Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.",
                    "type": "object"
                },
                "eq": {
                    "description": "This is an alias of {@link Long.equals}",
                    "type": "object"
                },
                "equals": {
                    "description": "Tests if this Long's value equals the specified's.",
                    "type": "object"
                },
                "eqz": {
                    "description": "This is an alias of {@link Long.isZero}",
                    "type": "object"
                },
                "ge": {
                    "description": "This is an alias of {@link Long.greaterThanOrEqual}",
                    "type": "object"
                },
                "getHighBits": {
                    "description": "Gets the high 32 bits as a signed integer.",
                    "type": "object"
                },
                "getHighBitsUnsigned": {
                    "description": "Gets the high 32 bits as an unsigned integer.",
                    "type": "object"
                },
                "getLowBits": {
                    "description": "Gets the low 32 bits as a signed integer.",
                    "type": "object"
                },
                "getLowBitsUnsigned": {
                    "description": "Gets the low 32 bits as an unsigned integer.",
                    "type": "object"
                },
                "getNumBitsAbs": {
                    "description": "Gets the number of bits needed to represent the absolute value of this Long.",
                    "type": "object"
                },
                "greaterThan": {
                    "description": "Tests if this Long's value is greater than the specified's.",
                    "type": "object"
                },
                "greaterThanOrEqual": {
                    "description": "Tests if this Long's value is greater than or equal the specified's.",
                    "type": "object"
                },
                "gt": {
                    "description": "This is an alias of {@link Long.greaterThan}",
                    "type": "object"
                },
                "gte": {
                    "description": "This is an alias of {@link Long.greaterThanOrEqual}",
                    "type": "object"
                },
                "high": {
                    "type": "number"
                },
                "isEven": {
                    "description": "Tests if this Long's value is even.",
                    "type": "object"
                },
                "isNegative": {
                    "description": "Tests if this Long's value is negative.",
                    "type": "object"
                },
                "isOdd": {
                    "description": "Tests if this Long's value is odd.",
                    "type": "object"
                },
                "isPositive": {
                    "description": "Tests if this Long's value is positive.",
                    "type": "object"
                },
                "isZero": {
                    "description": "Tests if this Long's value equals zero.",
                    "type": "object"
                },
                "le": {
                    "description": "This is an alias of {@link Long.lessThanOrEqual}",
                    "type": "object"
                },
                "lessThan": {
                    "description": "Tests if this Long's value is less than the specified's.",
                    "type": "object"
                },
                "lessThanOrEqual": {
                    "description": "Tests if this Long's value is less than or equal the specified's.",
                    "type": "object"
                },
                "low": {
                    "type": "number"
                },
                "lt": {
                    "description": "This is an alias of {@link Long#lessThan}.",
                    "type": "object"
                },
                "lte": {
                    "description": "This is an alias of {@link Long.lessThanOrEqual}",
                    "type": "object"
                },
                "mod": {
                    "description": "This is an alias of {@link Long.modulo}",
                    "type": "object"
                },
                "modulo": {
                    "description": "Returns this Long modulo the specified.",
                    "type": "object"
                },
                "mul": {
                    "description": "This is an alias of {@link Long.multiply}",
                    "type": "object"
                },
                "multiply": {
                    "description": "Returns the product of this and the specified Long.",
                    "type": "object"
                },
                "ne": {
                    "description": "This is an alias of {@link Long.notEquals}",
                    "type": "object"
                },
                "neg": {
                    "description": "This is an alias of {@link Long.negate}",
                    "type": "object"
                },
                "negate": {
                    "description": "Returns the Negation of this Long's value.",
                    "type": "object"
                },
                "neq": {
                    "description": "This is an alias of {@link Long.notEquals}",
                    "type": "object"
                },
                "not": {
                    "description": "Returns the bitwise NOT of this Long.",
                    "type": "object"
                },
                "notEquals": {
                    "description": "Tests if this Long's value differs from the specified's.",
                    "type": "object"
                },
                "or": {
                    "description": "Returns the bitwise OR of this Long and the specified.",
                    "type": "object"
                },
                "rem": {
                    "description": "This is an alias of {@link Long.modulo}",
                    "type": "object"
                },
                "shiftLeft": {
                    "description": "Returns this Long with bits shifted to the left by the given amount.",
                    "type": "object"
                },
                "shiftRight": {
                    "description": "Returns this Long with bits arithmetically shifted to the right by the given amount.",
                    "type": "object"
                },
                "shiftRightUnsigned": {
                    "description": "Returns this Long with bits logically shifted to the right by the given amount.",
                    "type": "object"
                },
                "shl": {
                    "description": "This is an alias of {@link Long.shiftLeft}",
                    "type": "object"
                },
                "shr": {
                    "description": "This is an alias of {@link Long.shiftRight}",
                    "type": "object"
                },
                "shr_u": {
                    "description": "This is an alias of {@link Long.shiftRightUnsigned}",
                    "type": "object"
                },
                "shru": {
                    "description": "This is an alias of {@link Long.shiftRightUnsigned}",
                    "type": "object"
                },
                "sub": {
                    "description": "This is an alias of {@link Long.subtract}",
                    "type": "object"
                },
                "subtract": {
                    "description": "Returns the difference of this and the specified Long.",
                    "type": "object"
                },
                "toBigInt": {
                    "description": "Converts the Long to a BigInt (arbitrary precision).",
                    "type": "object"
                },
                "toBytes": {
                    "description": "Converts this Long to its byte representation.",
                    "type": "object"
                },
                "toBytesBE": {
                    "description": "Converts this Long to its big endian byte representation.",
                    "type": "object"
                },
                "toBytesLE": {
                    "description": "Converts this Long to its little endian byte representation.",
                    "type": "object"
                },
                "toInt": {
                    "description": "Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.",
                    "type": "object"
                },
                "toNumber": {
                    "description": "Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).",
                    "type": "object"
                },
                "toSigned": {
                    "description": "Converts this Long to signed.",
                    "type": "object"
                },
                "toString": {
                    "description": "Converts the Long to a string written in the specified radix.",
                    "type": "object"
                },
                "toUnsigned": {
                    "description": "Converts this Long to unsigned.",
                    "type": "object"
                },
                "unsigned": {
                    "type": "boolean"
                },
                "xor": {
                    "description": "Returns the bitwise XOR of this Long and the given one.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "TopologyClosedEvent": {
            "description": "Emitted when topology is closed.",
            "properties": {
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "TopologyDescription": {
            "description": "Representation of a deployment of servers",
            "properties": {
                "commonWireVersion": {
                    "type": "number"
                },
                "compatibilityError": {
                    "type": "string"
                },
                "compatible": {
                    "type": "boolean"
                },
                "error": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/MongoServerError"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "hasDataBearingServers": {
                    "description": "Determines if this topology description has a data-bearing server available.",
                    "type": "boolean"
                },
                "hasKnownServers": {
                    "description": "Determines if the topology description has any known servers",
                    "type": "boolean"
                },
                "heartbeatFrequencyMS": {
                    "type": "number"
                },
                "localThresholdMS": {
                    "type": "number"
                },
                "logicalSessionTimeoutMinutes": {
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "maxElectionId": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ObjectID"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "maxSetVersion": {
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "servers": {
                    "$ref": "#/definitions/Map<string,ServerDescription>"
                },
                "setName": {
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "stale": {
                    "type": "boolean"
                },
                "type": {
                    "$ref": "#/definitions/TopologyType"
                }
            },
            "type": "object"
        },
        "TopologyDescriptionChangedEvent": {
            "description": "Emitted when topology description changes.",
            "properties": {
                "newDescription": {
                    "$ref": "#/definitions/TopologyDescription",
                    "description": "The new topology description"
                },
                "previousDescription": {
                    "$ref": "#/definitions/TopologyDescription",
                    "description": "The old topology description"
                },
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "TopologyOpeningEvent": {
            "description": "Emitted when topology is initialized.",
            "properties": {
                "topologyId": {
                    "description": "A unique identifier for the topology",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "TopologyType": {
            "description": "An enumeration of topology types we know about",
            "enum": [
                "LoadBalanced",
                "ReplicaSetNoPrimary",
                "ReplicaSetWithPrimary",
                "Sharded",
                "Single",
                "Unknown"
            ],
            "type": "string"
        },
        "TopologyVersion": {
            "properties": {
                "counter": {
                    "$ref": "#/definitions/Long"
                },
                "processId": {
                    "$ref": "#/definitions/ObjectID"
                }
            },
            "type": "object"
        },
        "Transaction": {
            "properties": {
                "isActive": {
                    "type": "boolean"
                },
                "isCommitted": {
                    "type": "boolean"
                },
                "isPinned": {
                    "type": "boolean"
                },
                "isStarting": {
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/TransactionOptions"
                },
                "recoveryToken": {
                    "$ref": "#/definitions/Document"
                }
            },
            "type": "object"
        },
        "TransactionOptions": {
            "description": "Configuration options for a transaction.",
            "properties": {
                "authdb": {
                    "type": "string"
                },
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Collation"
                },
                "comment": {
                    "description": "Comment to apply to the operation.\n\nIn server versions pre-4.4, 'comment' must be string.  A server\nerror will be thrown if any other type is provided.\n\nIn server versions 4.4 and above, 'comment' can be any valid BSON type."
                },
                "dbName": {
                    "type": "string"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "explain": {
                    "description": "Specifies the verbosity mode for the explain output.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "fullResponse": {
                    "type": "boolean"
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "maxCommitTimeMS": {
                    "description": "Specifies the maximum amount of time to allow a commit action on a transaction to run in milliseconds",
                    "type": "number"
                },
                "maxTimeMS": {
                    "type": "number"
                },
                "noResponse": {
                    "type": "boolean"
                },
                "omitReadPreference": {
                    "type": "boolean"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadConcern"
                        },
                        {
                            "properties": {
                                "level": {
                                    "$ref": "#/definitions/ReadConcernLevel"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "enum": [
                                "available",
                                "linearizable",
                                "local",
                                "majority",
                                "snapshot"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "A default read concern for commands in this transaction"
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "enum": [
                                "nearest",
                                "primary",
                                "primaryPreferred",
                                "secondary",
                                "secondaryPreferred"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "A default read preference for commands in this transaction"
                },
                "retryWrites": {
                    "description": "Should retry failed writes",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "session": {
                    "$ref": "#/definitions/ClientSession",
                    "description": "Specify ClientSession for this command"
                },
                "willRetryWrite": {
                    "type": "boolean"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern",
                    "description": "A default writeConcern for commands in this transaction"
                }
            },
            "type": "object"
        },
        "Transform": {
            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when `'end'` event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "TypedEventEmitter<any>": {
            "description": "Typescript type safe event emitter",
            "type": "object"
        },
        "Types.ArraySubdocument<any>": {
            "properties": {
                "$isSingleNested": {
                    "const": true,
                    "type": "boolean"
                },
                "$locals": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Empty object that you can use for storing properties on the document. This\nis handy for passing data to middleware without conflicting with Mongoose\ninternals."
                },
                "$op": {
                    "anyOf": [
                        {
                            "enum": [
                                "remove",
                                "save",
                                "validate"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "A string containing the current operation that Mongoose is executing\non this document. Can be `null`, `'save'`, `'validate'`, or `'remove'`."
                },
                "$where": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Set this property to add additional query filters when Mongoose saves this document and `isNew` is false."
                },
                "__v": {
                    "description": "This documents __v."
                },
                "_id": {
                    "description": "This documents _id."
                },
                "baseModelName": {
                    "description": "If this is a discriminator model, `baseModelName` is the name of the base model.",
                    "type": "string"
                },
                "collection": {
                    "$ref": "#/definitions/Collection<Document>",
                    "description": "Collection the model uses."
                },
                "db": {
                    "$ref": "#/definitions/Connection",
                    "description": "Connection the model uses."
                },
                "errors": {
                    "$ref": "#/definitions/Error.ValidationError",
                    "description": "Returns the current validation errors."
                },
                "id": {
                    "description": "The string version of this documents _id."
                },
                "isNew": {
                    "description": "Boolean flag specifying if the document is new.",
                    "type": "boolean"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The document's schema."
                }
            },
            "type": "object"
        },
        "Types.Decimal128": {
            "properties": {
                "_bsontype": {
                    "const": "Decimal128",
                    "type": "string"
                },
                "bytes": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Types.Map<any>": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Types.ObjectId": {
            "properties": {
                "_bsontype": {
                    "const": "ObjectID",
                    "type": "string"
                },
                "_id": {
                    "$ref": "#/definitions/Types.ObjectId",
                    "description": "Mongoose automatically adds a conveniency \"_id\" getter on the base ObjectId class"
                },
                "generationTime": {
                    "description": "The generation time of this ObjectId instance",
                    "type": "number"
                },
                "id": {
                    "additionalProperties": false,
                    "description": "The ObjectId bytes",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@1754": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Types.Subdocument<any>": {
            "properties": {
                "$isSingleNested": {
                    "const": true,
                    "type": "boolean"
                },
                "$locals": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Empty object that you can use for storing properties on the document. This\nis handy for passing data to middleware without conflicting with Mongoose\ninternals."
                },
                "$op": {
                    "anyOf": [
                        {
                            "enum": [
                                "remove",
                                "save",
                                "validate"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "A string containing the current operation that Mongoose is executing\non this document. Can be `null`, `'save'`, `'validate'`, or `'remove'`."
                },
                "$where": {
                    "$ref": "#/definitions/Record<string,unknown>",
                    "description": "Set this property to add additional query filters when Mongoose saves this document and `isNew` is false."
                },
                "__v": {
                    "description": "This documents __v."
                },
                "_id": {
                    "description": "This documents _id."
                },
                "baseModelName": {
                    "description": "If this is a discriminator model, `baseModelName` is the name of the base model.",
                    "type": "string"
                },
                "collection": {
                    "$ref": "#/definitions/Collection<Document>",
                    "description": "Collection the model uses."
                },
                "db": {
                    "$ref": "#/definitions/Connection",
                    "description": "Connection the model uses."
                },
                "errors": {
                    "$ref": "#/definitions/Error.ValidationError",
                    "description": "Returns the current validation errors."
                },
                "id": {
                    "description": "The string version of this documents _id."
                },
                "isNew": {
                    "description": "Boolean flag specifying if the document is new.",
                    "type": "boolean"
                },
                "schema": {
                    "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
                    "description": "The document's schema."
                }
            },
            "type": "object"
        },
        "UnorderedBulkOperation": {
            "properties": {
                "batches": {
                    "items": {
                        "$ref": "#/definitions/Batch<Document>"
                    },
                    "type": "array"
                },
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "isOrdered": {
                    "type": "boolean"
                },
                "operationId": {
                    "type": "number"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                }
            },
            "type": "object"
        },
        "UpdateStatement": {
            "properties": {
                "arrayFilters": {
                    "description": "An array of filter documents that determines which array elements to modify for an update operation on an array field.",
                    "items": {
                        "$ref": "#/definitions/Document"
                    },
                    "type": "array"
                },
                "collation": {
                    "$ref": "#/definitions/CollationOptions",
                    "description": "Specifies the collation to use for the operation."
                },
                "hint": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "A document or string that specifies the index to use to support the query predicate."
                },
                "multi": {
                    "description": "If true, updates all documents that meet the query criteria.",
                    "type": "boolean"
                },
                "q": {
                    "$ref": "#/definitions/Document",
                    "description": "The query that matches documents to update."
                },
                "u": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Document"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/Document"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "The modifications to apply."
                },
                "upsert": {
                    "description": "If true, perform an insert if no documents match the query.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ValidateFn<Schema.Types.Mixed>": {
            "type": "object"
        },
        "ValidateFn<any>": {
            "type": "object"
        },
        "ValidateOpts<Schema.Types.Mixed>": {
            "properties": {
                "message": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValidatorMessageFn"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "msg": {
                    "type": "string"
                },
                "propsParameter": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string"
                },
                "validator": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValidateFn<Schema.Types.Mixed>"
                        },
                        {
                            "$ref": "#/definitions/LegacyAsyncValidateFn<Schema.Types.Mixed>"
                        },
                        {
                            "$ref": "#/definitions/AsyncValidateFn<Schema.Types.Mixed>"
                        }
                    ]
                }
            },
            "type": "object"
        },
        "ValidateOpts<any>": {
            "properties": {
                "message": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValidatorMessageFn"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "msg": {
                    "type": "string"
                },
                "propsParameter": {
                    "type": "boolean"
                },
                "type": {
                    "type": "string"
                },
                "validator": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValidateFn<any>"
                        },
                        {
                            "$ref": "#/definitions/LegacyAsyncValidateFn<any>"
                        },
                        {
                            "$ref": "#/definitions/AsyncValidateFn<any>"
                        }
                    ]
                }
            },
            "type": "object"
        },
        "Validator": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "validator": {
                    "$ref": "#/definitions/Function"
                }
            },
            "type": "object"
        },
        "ValidatorMessageFn": {
            "type": "object"
        },
        "VirtualType<any>": {
            "type": "object"
        },
        "Writable": {
            "properties": {
                "destroyed": {
                    "description": "Is `true` after `writable.destroy()` has been called.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "WriteConcern": {
            "description": "A MongoDB WriteConcern, which describes the level of acknowledgement\nrequested from MongoDB for write operations.",
            "properties": {
                "fsync": {
                    "description": "equivalent to the j option",
                    "enum": [
                        1,
                        false,
                        true
                    ]
                },
                "j": {
                    "description": "request acknowledgment that the write operation has been written to the on-disk journal",
                    "type": "boolean"
                },
                "w": {
                    "anyOf": [
                        {
                            "const": "majority",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags."
                },
                "wtimeout": {
                    "description": "specify a time limit to prevent write operations from blocking indefinitely",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "WriteConcernError": {
            "description": "An error representing a failure by the server to apply the requested write concern to the bulk operation.",
            "properties": {
                "code": {
                    "description": "Write concern error code.",
                    "type": "number"
                },
                "err": {
                    "$ref": "#/definitions/WriteConcernErrorData"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document",
                    "description": "Write concern error info."
                },
                "errmsg": {
                    "description": "Write concern error message.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "WriteConcernErrorData": {
            "properties": {
                "code": {
                    "type": "number"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document"
                },
                "errmsg": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "WriteConcernSettings": {
            "properties": {
                "fsync": {
                    "description": "The file sync write concern",
                    "enum": [
                        1,
                        false,
                        true
                    ]
                },
                "j": {
                    "description": "The journal write concern",
                    "type": "boolean"
                },
                "journal": {
                    "description": "The journal write concern",
                    "type": "boolean"
                },
                "w": {
                    "anyOf": [
                        {
                            "const": "majority",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "The write concern"
                },
                "wtimeout": {
                    "description": "The write concern timeout",
                    "type": "number"
                },
                "wtimeoutMS": {
                    "description": "The write concern timeout",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "WriteError": {
            "description": "An error that occurred during a BulkWrite on the server.",
            "properties": {
                "code": {
                    "description": "WriteError code.",
                    "type": "number"
                },
                "err": {
                    "$ref": "#/definitions/BulkWriteOperationError"
                },
                "errInfo": {
                    "$ref": "#/definitions/Document",
                    "description": "WriteError details."
                },
                "errmsg": {
                    "description": "WriteError message.",
                    "type": "string"
                },
                "index": {
                    "description": "WriteError original bulk operation index.",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "import(\"events\")": {
            "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:",
            "type": "object"
        },
        "mquery": {
            "type": "object"
        },
        "typeofDuplex": {
            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Duplex"
                }
            },
            "type": "object"
        },
        "typeofEventEmitterAsyncResource": {
            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves.",
            "properties": {
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "prototype": {
                    "$ref": "#/definitions/EventEmitterAsyncResource"
                }
            },
            "type": "object"
        },
        "typeofPassThrough": {
            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams.",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/PassThrough"
                }
            },
            "type": "object"
        },
        "typeofReadable": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Readable"
                }
            },
            "type": "object"
        },
        "typeofSchemaType": {
            "properties": {
                "prototype": {
                    "$ref": "#/definitions/SchemaType<any,any>"
                }
            },
            "type": "object"
        },
        "typeofStream": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Stream"
                }
            },
            "type": "object"
        },
        "typeofTransform": {
            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Transform"
                }
            },
            "type": "object"
        },
        "typeofWritable": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Writable"
                }
            },
            "type": "object"
        },
        "typeofcaptureRejectionSymbol": {
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "typeoferrorMonitor": {
            "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.",
            "properties": {
                "__@toStringTag@1754": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "typeofimport(\"events\")": {
            "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:",
            "properties": {
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                },
                "captureRejections": {
                    "description": "Sets or gets the default captureRejection value for all emitters.",
                    "type": "boolean"
                },
                "defaultMaxListeners": {
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                },
                "prototype": {
                    "$ref": "#/definitions/import(\"events\")"
                }
            },
            "type": "object"
        },
        "typeofimport(\"mongoose\")": {
            "properties": {
                "Aggregate": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Aggregate<any>"
                        }
                    },
                    "type": "object"
                },
                "Collection": {
                    "$ref": "#/definitions/Collection<Document>"
                },
                "Connection": {
                    "properties": {
                        "EventEmitter": {
                            "$ref": "#/definitions/typeofimport(\"events\")",
                            "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                        },
                        "EventEmitterAsyncResource": {
                            "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                        },
                        "captureRejectionSymbol": {
                            "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                        },
                        "captureRejections": {
                            "description": "Sets or gets the default captureRejection value for all emitters.",
                            "type": "boolean"
                        },
                        "defaultMaxListeners": {
                            "type": "number"
                        },
                        "errorMonitor": {
                            "$ref": "#/definitions/typeoferrorMonitor",
                            "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                        },
                        "prototype": {
                            "$ref": "#/definitions/Connection"
                        }
                    },
                    "type": "object"
                },
                "ConnectionStates": {
                    "additionalProperties": false,
                    "description": "Connection ready state\n\n- 0 = disconnected\n- 1 = connected\n- 2 = connecting\n- 3 = disconnecting\n- 99 = uninitialized",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "string"
                        }
                    },
                    "properties": {
                        "connected": {
                            "$ref": "#/definitions/ConnectionStates.connected",
                            "default": 1
                        },
                        "connecting": {
                            "$ref": "#/definitions/ConnectionStates.connecting",
                            "default": 2
                        },
                        "disconnected": {
                            "$ref": "#/definitions/ConnectionStates.disconnected",
                            "default": 0
                        },
                        "disconnecting": {
                            "$ref": "#/definitions/ConnectionStates.disconnecting",
                            "default": 3
                        },
                        "uninitialized": {
                            "$ref": "#/definitions/ConnectionStates.uninitialized",
                            "default": 99
                        }
                    },
                    "type": "object"
                },
                "Cursor": {
                    "properties": {
                        "Duplex": {
                            "$ref": "#/definitions/typeofDuplex",
                            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                        },
                        "EventEmitter": {
                            "$ref": "#/definitions/typeofimport(\"events\")",
                            "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                        },
                        "EventEmitterAsyncResource": {
                            "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                        },
                        "PassThrough": {
                            "$ref": "#/definitions/typeofPassThrough",
                            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                        },
                        "Readable": {
                            "$ref": "#/definitions/typeofReadable"
                        },
                        "Stream": {
                            "$ref": "#/definitions/typeofStream"
                        },
                        "Transform": {
                            "$ref": "#/definitions/typeofTransform",
                            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                        },
                        "Writable": {
                            "$ref": "#/definitions/typeofWritable"
                        },
                        "addAbortSignal": {
                            "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                            "type": "object"
                        },
                        "captureRejectionSymbol": {
                            "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                        },
                        "captureRejections": {
                            "description": "Sets or gets the default captureRejection value for all emitters.",
                            "type": "boolean"
                        },
                        "consumers": {
                            "properties": {
                                "arrayBuffer": {
                                    "type": "object"
                                },
                                "blob": {
                                    "type": "object"
                                },
                                "buffer": {
                                    "type": "object"
                                },
                                "json": {
                                    "type": "object"
                                },
                                "text": {
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        },
                        "defaultMaxListeners": {
                            "type": "number"
                        },
                        "errorMonitor": {
                            "$ref": "#/definitions/typeoferrorMonitor",
                            "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                        },
                        "finished": {
                            "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        },
                        "isErrored": {
                            "description": "Returns whether the stream has encountered an error.",
                            "type": "object"
                        },
                        "isReadable": {
                            "description": "Returns whether the stream is readable.",
                            "type": "object"
                        },
                        "pipeline": {
                            "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        },
                        "promises": {
                            "properties": {
                                "finished": {
                                    "type": "object"
                                },
                                "pipeline": {
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        },
                        "prototype": {
                            "$ref": "#/definitions/Cursor<any,any>"
                        }
                    },
                    "type": "object"
                },
                "Document": {
                    "description": "Generic types for Document:\n*  T - the type of _id\n*  TQueryHelpers - Object with any helpers that should be mixed into the Query type\n*  DocType - the type of the actual Document created",
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Document<any,any,any>"
                        }
                    },
                    "type": "object"
                },
                "Error": {
                    "properties": {
                        "CastError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.CastError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "DisconnectedError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.DisconnectedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "DivergentArrayError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.DivergentArrayError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "DocumentNotFoundError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.DocumentNotFoundError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "Messages": {},
                        "MissingSchemaError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.MissingSchemaError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongooseServerSelectionError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.MongooseServerSelectionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectExpectedError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ObjectExpectedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectParameterError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ObjectParameterError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "OverwriteModelError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.OverwriteModelError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ParallelSaveError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ParallelSaveError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ParallelValidateError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ParallelValidateError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "StrictModeError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.StrictModeError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "StrictPopulateError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.StrictPopulateError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "SyncIndexesError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.SyncIndexesError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ValidationError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ValidationError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ValidatorError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.ValidatorError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "VersionError": {
                            "properties": {
                                "Messages": {},
                                "messages": {},
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Error.VersionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "messages": {},
                        "prepareStackTrace": {
                            "description": "Optional override for formatting stack traces",
                            "type": "object"
                        },
                        "prototype": {
                            "$ref": "#/definitions/Error"
                        },
                        "stackTraceLimit": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "Model": {
                    "$ref": "#/definitions/Model<any,{},{},{},any>"
                },
                "Mongoose": {
                    "description": "Mongoose constructor. The exports object of the `mongoose` module is an instance of this\nclass. Most apps will only use this one instance.",
                    "type": "object"
                },
                "MongooseError": {
                    "properties": {
                        "Messages": {},
                        "messages": {},
                        "prepareStackTrace": {
                            "description": "Optional override for formatting stack traces",
                            "type": "object"
                        },
                        "prototype": {
                            "$ref": "#/definitions/MongooseError"
                        },
                        "stackTraceLimit": {
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "NativeBuffer": {
                    "properties": {
                        "poolSize": {
                            "description": "This is the size (in bytes) of pre-allocated internal `Buffer` instances used\nfor pooling. This value may be modified.",
                            "type": "number"
                        },
                        "prototype": {
                            "items": {
                                "type": "number"
                            },
                            "type": "array"
                        }
                    },
                    "type": "object"
                },
                "Promise": {},
                "PromiseProvider": {},
                "Query": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/Query<any,any,any,any>"
                        }
                    },
                    "type": "object"
                },
                "STATES": {
                    "additionalProperties": false,
                    "description": "Expose connection states for user-land",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "string"
                        }
                    },
                    "properties": {
                        "connected": {
                            "$ref": "#/definitions/ConnectionStates.connected",
                            "default": 1
                        },
                        "connecting": {
                            "$ref": "#/definitions/ConnectionStates.connecting",
                            "default": 2
                        },
                        "disconnected": {
                            "$ref": "#/definitions/ConnectionStates.disconnected",
                            "default": 0
                        },
                        "disconnecting": {
                            "$ref": "#/definitions/ConnectionStates.disconnecting",
                            "default": 3
                        },
                        "uninitialized": {
                            "$ref": "#/definitions/ConnectionStates.uninitialized",
                            "default": 99
                        }
                    },
                    "type": "object"
                },
                "Schema": {
                    "properties": {
                        "EventEmitter": {
                            "$ref": "#/definitions/typeofimport(\"events\")",
                            "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                        },
                        "EventEmitterAsyncResource": {
                            "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                        },
                        "Types": {
                            "properties": {
                                "Array": {
                                    "properties": {
                                        "options": {
                                            "properties": {
                                                "castNonArrays": {
                                                    "type": "boolean"
                                                }
                                            },
                                            "type": "object"
                                        },
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Array"
                                        },
                                        "schemaName": {
                                            "const": "Array",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Boolean": {
                                    "properties": {
                                        "convertToFalse": {
                                            "$ref": "#/definitions/Set<any>",
                                            "description": "Configure which values get casted to `false`."
                                        },
                                        "convertToTrue": {
                                            "$ref": "#/definitions/Set<any>",
                                            "description": "Configure which values get casted to `true`."
                                        },
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Boolean"
                                        },
                                        "schemaName": {
                                            "const": "Boolean",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Buffer": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Buffer"
                                        },
                                        "schemaName": {
                                            "const": "Buffer",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Date": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Date"
                                        },
                                        "schemaName": {
                                            "const": "Date",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Decimal128": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Decimal128"
                                        },
                                        "schemaName": {
                                            "const": "Decimal128",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "DocumentArray": {
                                    "properties": {
                                        "options": {
                                            "properties": {
                                                "castNonArrays": {
                                                    "type": "boolean"
                                                }
                                            },
                                            "type": "object"
                                        },
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.DocumentArray"
                                        },
                                        "schemaName": {
                                            "const": "DocumentArray",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Map": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Map"
                                        },
                                        "schemaName": {
                                            "const": "Map",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Mixed": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Mixed"
                                        },
                                        "schemaName": {
                                            "const": "Mixed",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Number": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Number"
                                        },
                                        "schemaName": {
                                            "const": "Number",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "ObjectId": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.ObjectId"
                                        },
                                        "schemaName": {
                                            "const": "ObjectId",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "String": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.String"
                                        },
                                        "schemaName": {
                                            "const": "String",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "Subdocument": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.Subdocument"
                                        },
                                        "schemaName": {
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                },
                                "UUID": {
                                    "properties": {
                                        "prototype": {
                                            "$ref": "#/definitions/Schema.Types.UUID"
                                        },
                                        "schemaName": {
                                            "const": "UUID",
                                            "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        },
                        "captureRejectionSymbol": {
                            "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                        },
                        "captureRejections": {
                            "description": "Sets or gets the default captureRejection value for all emitters.",
                            "type": "boolean"
                        },
                        "defaultMaxListeners": {
                            "type": "number"
                        },
                        "errorMonitor": {
                            "$ref": "#/definitions/typeoferrorMonitor",
                            "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                        },
                        "prototype": {
                            "$ref": "#/definitions/Schema<any,any,any,any,any,any,any,any>"
                        }
                    },
                    "type": "object"
                },
                "SchemaType": {
                    "$ref": "#/definitions/typeofSchemaType"
                },
                "SchemaTypeOptions": {
                    "additionalProperties": {},
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/SchemaTypeOptions<any>"
                        }
                    },
                    "type": "object"
                },
                "SchemaTypes": {
                    "description": "The various Mongoose SchemaTypes.",
                    "properties": {
                        "Array": {
                            "properties": {
                                "options": {
                                    "properties": {
                                        "castNonArrays": {
                                            "type": "boolean"
                                        }
                                    },
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Array"
                                },
                                "schemaName": {
                                    "const": "Array",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Boolean": {
                            "properties": {
                                "convertToFalse": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `false`."
                                },
                                "convertToTrue": {
                                    "$ref": "#/definitions/Set<any>",
                                    "description": "Configure which values get casted to `true`."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Boolean"
                                },
                                "schemaName": {
                                    "const": "Boolean",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Buffer": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Buffer"
                                },
                                "schemaName": {
                                    "const": "Buffer",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Date": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Date"
                                },
                                "schemaName": {
                                    "const": "Date",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Decimal128": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Decimal128"
                                },
                                "schemaName": {
                                    "const": "Decimal128",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "DocumentArray": {
                            "properties": {
                                "options": {
                                    "properties": {
                                        "castNonArrays": {
                                            "type": "boolean"
                                        }
                                    },
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.DocumentArray"
                                },
                                "schemaName": {
                                    "const": "DocumentArray",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Map": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Map"
                                },
                                "schemaName": {
                                    "const": "Map",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Mixed": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Mixed"
                                },
                                "schemaName": {
                                    "const": "Mixed",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Number": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Number"
                                },
                                "schemaName": {
                                    "const": "Number",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectId": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.ObjectId"
                                },
                                "schemaName": {
                                    "const": "ObjectId",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "String": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.String"
                                },
                                "schemaName": {
                                    "const": "String",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Subdocument": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.Subdocument"
                                },
                                "schemaName": {
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "UUID": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Schema.Types.UUID"
                                },
                                "schemaName": {
                                    "const": "UUID",
                                    "description": "This schema type's name, to defend against minifiers that mangle function names.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "Types": {
                    "properties": {
                        "Array": {
                            "properties": {
                                "__@species@1110": {
                                    "$ref": "#/definitions/ArrayConstructor"
                                },
                                "prototype": {
                                    "items": {},
                                    "type": "array"
                                }
                            },
                            "type": "object"
                        },
                        "ArraySubdocument": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Types.ArraySubdocument<any>"
                                }
                            },
                            "type": "object"
                        },
                        "Buffer": {
                            "properties": {
                                "poolSize": {
                                    "description": "This is the size (in bytes) of pre-allocated internal `Buffer` instances used\nfor pooling. This value may be modified.",
                                    "type": "number"
                                },
                                "prototype": {
                                    "items": {
                                        "type": "number"
                                    },
                                    "type": "array"
                                }
                            },
                            "type": "object"
                        },
                        "Decimal128": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Types.Decimal128"
                                }
                            },
                            "type": "object"
                        },
                        "DocumentArray": {
                            "properties": {
                                "__@species@1110": {
                                    "$ref": "#/definitions/ArrayConstructor"
                                },
                                "prototype": {
                                    "items": {},
                                    "type": "array"
                                }
                            },
                            "type": "object"
                        },
                        "Map": {
                            "properties": {
                                "__@species@1110": {
                                    "$ref": "#/definitions/MapConstructor"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Types.Map<any>"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectId": {
                            "properties": {
                                "cacheHexString": {
                                    "type": "boolean"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Types.ObjectId"
                                }
                            },
                            "type": "object"
                        },
                        "Subdocument": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Types.Subdocument<any>"
                                }
                            },
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "VirtualType": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/VirtualType<any>"
                        }
                    },
                    "type": "object"
                },
                "connect": {
                    "description": "Opens Mongoose's default connection to MongoDB, see [connections docs](https://mongoosejs.com/docs/connections.html)",
                    "type": "object"
                },
                "connection": {
                    "$ref": "#/definitions/Connection",
                    "description": "The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](#mongoose_Mongoose-connections)."
                },
                "connections": {
                    "description": "An array containing all connections associated with this Mongoose instance.",
                    "items": {
                        "$ref": "#/definitions/Connection"
                    },
                    "type": "array"
                },
                "createConnection": {
                    "description": "Creates a Connection instance.",
                    "type": "object"
                },
                "default": {
                    "$ref": "#/definitions/typeofimport(\"mongoose\")"
                },
                "deleteModel": {
                    "description": "Removes the model named `name` from the default connection, if it exists.\nYou can use this function to clean up any models you created in your tests to\nprevent OverwriteModelErrors.",
                    "type": "object"
                },
                "disconnect": {
                    "type": "object"
                },
                "get": {
                    "description": "Gets mongoose options",
                    "type": "object"
                },
                "isObjectIdOrHexString": {
                    "description": "Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the\ngiven value is a 24 character hex string, which is the most commonly used string representation\nof an ObjectId.",
                    "type": "object"
                },
                "isValidObjectId": {
                    "description": "Returns true if Mongoose can cast the given value to an ObjectId, or\nfalse otherwise.",
                    "type": "object"
                },
                "model": {
                    "type": "object"
                },
                "modelNames": {
                    "description": "Returns an array of model names created on this instance of Mongoose.",
                    "type": "object"
                },
                "models": {
                    "$ref": "#/definitions/Models",
                    "description": "An array containing all models associated with this Mongoose instance."
                },
                "mongo": {
                    "description": "The node-mongodb-native driver Mongoose uses.",
                    "properties": {
                        "AbstractCursor": {
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/AbstractCursor<any,any>"
                                }
                            },
                            "type": "object"
                        },
                        "Admin": {
                            "description": "The **Admin** class is an internal class that allows convenient access to\nthe admin functionality and commands for MongoDB.\n\n**ADMIN Cannot directly be instantiated**",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Admin"
                                }
                            },
                            "type": "object"
                        },
                        "AggregationCursor": {
                            "description": "The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\nallowing for iteration over the results returned from the underlying query. It supports\none by one document iteration, conversion to an array or can be iterated as a Node 4.X\nor higher stream",
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/AggregationCursor<any>"
                                }
                            },
                            "type": "object"
                        },
                        "AuthMechanism": {
                            "properties": {
                                "MONGODB_AWS": {
                                    "const": "MONGODB-AWS",
                                    "type": "string"
                                },
                                "MONGODB_CR": {
                                    "const": "MONGODB-CR",
                                    "type": "string"
                                },
                                "MONGODB_DEFAULT": {
                                    "const": "DEFAULT",
                                    "type": "string"
                                },
                                "MONGODB_GSSAPI": {
                                    "const": "GSSAPI",
                                    "type": "string"
                                },
                                "MONGODB_PLAIN": {
                                    "const": "PLAIN",
                                    "type": "string"
                                },
                                "MONGODB_SCRAM_SHA1": {
                                    "const": "SCRAM-SHA-1",
                                    "type": "string"
                                },
                                "MONGODB_SCRAM_SHA256": {
                                    "const": "SCRAM-SHA-256",
                                    "type": "string"
                                },
                                "MONGODB_X509": {
                                    "const": "MONGODB-X509",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "AutoEncryptionLoggerLevel": {
                            "properties": {
                                "Error": {
                                    "const": 1,
                                    "type": "number"
                                },
                                "FatalError": {
                                    "const": 0,
                                    "type": "number"
                                },
                                "Info": {
                                    "const": 3,
                                    "type": "number"
                                },
                                "Trace": {
                                    "const": 4,
                                    "type": "number"
                                },
                                "Warning": {
                                    "const": 2,
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "BSONRegExp": {
                            "description": "A class representation of the BSON RegExp type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/BSONRegExp"
                                }
                            },
                            "type": "object"
                        },
                        "BSONSymbol": {
                            "description": "A class representation of the BSON Symbol type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/BSONSymbol"
                                }
                            },
                            "type": "object"
                        },
                        "BSONType": {
                            "properties": {
                                "array": {
                                    "const": 4,
                                    "type": "number"
                                },
                                "binData": {
                                    "const": 5,
                                    "type": "number"
                                },
                                "bool": {
                                    "const": 8,
                                    "type": "number"
                                },
                                "date": {
                                    "const": 9,
                                    "type": "number"
                                },
                                "dbPointer": {
                                    "const": 12,
                                    "type": "number"
                                },
                                "decimal": {
                                    "const": 19,
                                    "type": "number"
                                },
                                "double": {
                                    "const": 1,
                                    "type": "number"
                                },
                                "int": {
                                    "const": 16,
                                    "type": "number"
                                },
                                "javascript": {
                                    "const": 13,
                                    "type": "number"
                                },
                                "javascriptWithScope": {
                                    "const": 15,
                                    "type": "number"
                                },
                                "long": {
                                    "const": 18,
                                    "type": "number"
                                },
                                "maxKey": {
                                    "const": 127,
                                    "type": "number"
                                },
                                "minKey": {
                                    "const": -1,
                                    "type": "number"
                                },
                                "null": {
                                    "const": 10,
                                    "type": "number"
                                },
                                "object": {
                                    "const": 3,
                                    "type": "number"
                                },
                                "objectId": {
                                    "const": 7,
                                    "type": "number"
                                },
                                "regex": {
                                    "const": 11,
                                    "type": "number"
                                },
                                "string": {
                                    "const": 2,
                                    "type": "number"
                                },
                                "symbol": {
                                    "const": 14,
                                    "type": "number"
                                },
                                "timestamp": {
                                    "const": 17,
                                    "type": "number"
                                },
                                "undefined": {
                                    "const": 6,
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "Batch": {
                            "description": "Keeps the state of a unordered batch so we can rewrite the results\ncorrectly after command execution",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Batch<any>"
                                }
                            },
                            "type": "object"
                        },
                        "BatchType": {
                            "properties": {
                                "DELETE": {
                                    "const": 3,
                                    "type": "number"
                                },
                                "INSERT": {
                                    "const": 1,
                                    "type": "number"
                                },
                                "UPDATE": {
                                    "const": 2,
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "Binary": {
                            "description": "A class representation of the BSON Binary type.",
                            "properties": {
                                "BUFFER_SIZE": {
                                    "const": 256,
                                    "default": 256,
                                    "description": "Initial buffer default size",
                                    "type": "number"
                                },
                                "SUBTYPE_BYTE_ARRAY": {
                                    "const": 2,
                                    "default": 2,
                                    "description": "Byte Array BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_COLUMN": {
                                    "const": 7,
                                    "default": 7,
                                    "description": "Column BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_DEFAULT": {
                                    "const": 0,
                                    "default": 0,
                                    "description": "Default BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_ENCRYPTED": {
                                    "const": 6,
                                    "default": 6,
                                    "description": "Encrypted BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_FUNCTION": {
                                    "const": 1,
                                    "default": 1,
                                    "description": "Function BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_MD5": {
                                    "const": 5,
                                    "default": 5,
                                    "description": "MD5 BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_USER_DEFINED": {
                                    "const": 128,
                                    "default": 128,
                                    "description": "User BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_UUID": {
                                    "const": 4,
                                    "default": 4,
                                    "description": "UUID BSON type",
                                    "type": "number"
                                },
                                "SUBTYPE_UUID_OLD": {
                                    "const": 3,
                                    "default": 3,
                                    "description": "Deprecated UUID BSON type",
                                    "type": "number"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Binary"
                                }
                            },
                            "type": "object"
                        },
                        "BulkOperationBase": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/BulkOperationBase"
                                }
                            },
                            "type": "object"
                        },
                        "BulkWriteResult": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/BulkWriteResult"
                                }
                            },
                            "type": "object"
                        },
                        "CURSOR_FLAGS": {
                            "items": [
                                {
                                    "const": "tailable",
                                    "type": "string"
                                },
                                {
                                    "const": "oplogReplay",
                                    "type": "string"
                                },
                                {
                                    "const": "noCursorTimeout",
                                    "type": "string"
                                },
                                {
                                    "const": "awaitData",
                                    "type": "string"
                                },
                                {
                                    "const": "exhaust",
                                    "type": "string"
                                },
                                {
                                    "const": "partial",
                                    "type": "string"
                                }
                            ],
                            "maxItems": 6,
                            "minItems": 6,
                            "type": "array"
                        },
                        "CancellationToken": {
                            "properties": {
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/CancellationToken"
                                }
                            },
                            "type": "object"
                        },
                        "ChangeStream": {
                            "description": "Creates a new Change Stream instance. Normally created using {@link Collection#watch Collection.watch()}.",
                            "properties": {
                                "CHANGE": {
                                    "const": "change",
                                    "description": "Fired for each new matching change in the specified namespace. Attaching a `change`\nevent listener to a Change Stream will switch the stream into flowing mode. Data will\nthen be passed as soon as it is available.",
                                    "type": "string"
                                },
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "END": {
                                    "const": "end",
                                    "type": "string"
                                },
                                "ERROR": {
                                    "const": "error",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "INIT": {
                                    "const": "init",
                                    "type": "string"
                                },
                                "MORE": {
                                    "const": "more",
                                    "type": "string"
                                },
                                "RESPONSE": {
                                    "const": "response",
                                    "type": "string"
                                },
                                "RESUME_TOKEN_CHANGED": {
                                    "const": "resumeTokenChanged",
                                    "description": "Emitted each time the change stream stores a new resume token.",
                                    "type": "string"
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ChangeStream<any,any>"
                                }
                            },
                            "type": "object"
                        },
                        "ClientSession": {
                            "description": "A class representing a client session on the server\n\nNOTE: not meant to be instantiated directly.",
                            "properties": {
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ClientSession"
                                }
                            },
                            "type": "object"
                        },
                        "Code": {
                            "description": "A class representation of the BSON Code type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Code"
                                }
                            },
                            "type": "object"
                        },
                        "Collection": {
                            "description": "The **Collection** class is an internal class that embodies a MongoDB collection\nallowing for insert/find/update/delete and other command operation on that MongoDB collection.\n\n**COLLECTION Cannot directly be instantiated**",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Collection<any>"
                                }
                            },
                            "type": "object"
                        },
                        "CommandFailedEvent": {
                            "description": "An event indicating the failure of a given command",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/CommandFailedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "CommandStartedEvent": {
                            "description": "An event indicating the start of a given",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/CommandStartedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "CommandSucceededEvent": {
                            "description": "An event indicating the success of a given command",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/CommandSucceededEvent"
                                }
                            },
                            "type": "object"
                        },
                        "Compressor": {
                            "properties": {
                                "none": {
                                    "const": 0,
                                    "type": "number"
                                },
                                "snappy": {
                                    "const": 1,
                                    "type": "number"
                                },
                                "zlib": {
                                    "const": 2,
                                    "type": "number"
                                },
                                "zstd": {
                                    "const": 3,
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionCheckOutFailedEvent": {
                            "description": "An event published when a request to check a connection out fails",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionCheckOutFailedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionCheckOutStartedEvent": {
                            "description": "An event published when a request to check a connection out begins",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionCheckOutStartedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionCheckedInEvent": {
                            "description": "An event published when a connection is checked into the connection pool",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionCheckedInEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionCheckedOutEvent": {
                            "description": "An event published when a connection is checked out of the connection pool",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionCheckedOutEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionClosedEvent": {
                            "description": "An event published when a connection is closed",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionClosedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionCreatedEvent": {
                            "description": "An event published when a connection pool creates a new connection",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionCreatedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionPoolClearedEvent": {
                            "description": "An event published when a connection pool is cleared",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionPoolClearedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionPoolClosedEvent": {
                            "description": "An event published when a connection pool is closed",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionPoolClosedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionPoolCreatedEvent": {
                            "description": "An event published when a connection pool is created",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionPoolCreatedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionPoolMonitoringEvent": {
                            "description": "The base export class for all monitoring events published from the connection pool",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionPoolMonitoringEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionPoolReadyEvent": {
                            "description": "An event published when a connection pool is ready",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionPoolReadyEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ConnectionReadyEvent": {
                            "description": "An event published when a connection is ready for use",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ConnectionReadyEvent"
                                }
                            },
                            "type": "object"
                        },
                        "DBRef": {
                            "description": "A class representation of the BSON DBRef type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/DBRef"
                                }
                            },
                            "type": "object"
                        },
                        "Db": {
                            "description": "The **Db** class is a class that represents a MongoDB Database.",
                            "properties": {
                                "SYSTEM_COMMAND_COLLECTION": {
                                    "type": "string"
                                },
                                "SYSTEM_INDEX_COLLECTION": {
                                    "type": "string"
                                },
                                "SYSTEM_JS_COLLECTION": {
                                    "type": "string"
                                },
                                "SYSTEM_NAMESPACE_COLLECTION": {
                                    "type": "string"
                                },
                                "SYSTEM_PROFILE_COLLECTION": {
                                    "type": "string"
                                },
                                "SYSTEM_USER_COLLECTION": {
                                    "type": "string"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Db"
                                }
                            },
                            "type": "object"
                        },
                        "Decimal128": {
                            "description": "A class representation of the BSON Decimal128 type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Decimal128"
                                }
                            },
                            "type": "object"
                        },
                        "Double": {
                            "description": "A class representation of the BSON Double type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Double"
                                }
                            },
                            "type": "object"
                        },
                        "ExplainVerbosity": {
                            "properties": {
                                "allPlansExecution": {
                                    "const": "allPlansExecution",
                                    "type": "string"
                                },
                                "executionStats": {
                                    "const": "executionStats",
                                    "type": "string"
                                },
                                "queryPlanner": {
                                    "const": "queryPlanner",
                                    "type": "string"
                                },
                                "queryPlannerExtended": {
                                    "const": "queryPlannerExtended",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "FindCursor": {
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/FindCursor<any>"
                                }
                            },
                            "type": "object"
                        },
                        "FindOperators": {
                            "description": "A builder object that is returned from {@link BulkOperationBase#find}.\nIs used to build a write operation that involves a query filter.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/FindOperators"
                                }
                            },
                            "type": "object"
                        },
                        "GSSAPICanonicalizationValue": {
                            "properties": {
                                "forward": {
                                    "const": "forward",
                                    "type": "string"
                                },
                                "forwardAndReverse": {
                                    "const": "forwardAndReverse",
                                    "type": "string"
                                },
                                "none": {
                                    "const": "none",
                                    "type": "string"
                                },
                                "off": {
                                    "const": false,
                                    "type": "boolean"
                                },
                                "on": {
                                    "const": true,
                                    "type": "boolean"
                                }
                            },
                            "type": "object"
                        },
                        "GridFSBucket": {
                            "description": "Constructor for a streaming GridFS interface",
                            "properties": {
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "INDEX": {
                                    "const": "index",
                                    "description": "When the first call to openUploadStream is made, the upload stream will\ncheck to see if it needs to create the proper indexes on the chunks and\nfiles collections. This event is fired either when 1) it determines that\nno index creation is necessary, 2) when it successfully creates the\nnecessary indexes.",
                                    "type": "string"
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/GridFSBucket"
                                }
                            },
                            "type": "object"
                        },
                        "GridFSBucketReadStream": {
                            "description": "A readable stream that enables you to read buffers from GridFS.\n\nDo not instantiate this class directly. Use `openDownloadStream()` instead.",
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "description": "Fired when the stream is exhausted and the underlying cursor is killed",
                                    "type": "string"
                                },
                                "DATA": {
                                    "const": "data",
                                    "description": "Emitted when a chunk of data is available to be consumed.",
                                    "type": "string"
                                },
                                "Duplex": {
                                    "$ref": "#/definitions/typeofDuplex",
                                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                                },
                                "END": {
                                    "const": "end",
                                    "description": "Fired when the stream is exhausted (no more data events).",
                                    "type": "string"
                                },
                                "ERROR": {
                                    "const": "error",
                                    "description": "An error occurred",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "FILE": {
                                    "const": "file",
                                    "description": "Fires when the stream loaded the file document corresponding to the provided id.",
                                    "type": "string"
                                },
                                "PassThrough": {
                                    "$ref": "#/definitions/typeofPassThrough",
                                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                                },
                                "Readable": {
                                    "$ref": "#/definitions/typeofReadable"
                                },
                                "Stream": {
                                    "$ref": "#/definitions/typeofStream"
                                },
                                "Transform": {
                                    "$ref": "#/definitions/typeofTransform",
                                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                                },
                                "Writable": {
                                    "$ref": "#/definitions/typeofWritable"
                                },
                                "addAbortSignal": {
                                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                                    "type": "object"
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "consumers": {
                                    "properties": {
                                        "arrayBuffer": {
                                            "type": "object"
                                        },
                                        "blob": {
                                            "type": "object"
                                        },
                                        "buffer": {
                                            "type": "object"
                                        },
                                        "json": {
                                            "type": "object"
                                        },
                                        "text": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "finished": {
                                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                                    "properties": {
                                        "__promisify__": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "isErrored": {
                                    "description": "Returns whether the stream has encountered an error.",
                                    "type": "object"
                                },
                                "isReadable": {
                                    "description": "Returns whether the stream is readable.",
                                    "type": "object"
                                },
                                "pipeline": {
                                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                                    "properties": {
                                        "__promisify__": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "promises": {
                                    "properties": {
                                        "finished": {
                                            "type": "object"
                                        },
                                        "pipeline": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/GridFSBucketReadStream"
                                }
                            },
                            "type": "object"
                        },
                        "GridFSBucketWriteStream": {
                            "description": "A writable stream that enables you to write buffers to GridFS.\n\nDo not instantiate this class directly. Use `openUploadStream()` instead.",
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "default": "close",
                                    "type": "string"
                                },
                                "Duplex": {
                                    "$ref": "#/definitions/typeofDuplex",
                                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                                },
                                "ERROR": {
                                    "const": "error",
                                    "default": "error",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "FINISH": {
                                    "const": "finish",
                                    "default": "finish",
                                    "description": "`end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.",
                                    "type": "string"
                                },
                                "PassThrough": {
                                    "$ref": "#/definitions/typeofPassThrough",
                                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams."
                                },
                                "Readable": {
                                    "$ref": "#/definitions/typeofReadable"
                                },
                                "Stream": {
                                    "$ref": "#/definitions/typeofStream"
                                },
                                "Transform": {
                                    "$ref": "#/definitions/typeofTransform",
                                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                                },
                                "Writable": {
                                    "$ref": "#/definitions/typeofWritable"
                                },
                                "addAbortSignal": {
                                    "description": "Attaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.\n\n```js\nconst fs = require('fs');\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json'))\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```",
                                    "type": "object"
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "consumers": {
                                    "properties": {
                                        "arrayBuffer": {
                                            "type": "object"
                                        },
                                        "blob": {
                                            "type": "object"
                                        },
                                        "buffer": {
                                            "type": "object"
                                        },
                                        "json": {
                                            "type": "object"
                                        },
                                        "text": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "finished": {
                                    "description": "A function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nconst { finished } = require('stream');\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.\n\nThe `finished` API provides promise version:\n\n```js\nconst { finished } = require('stream/promises');\n\nconst rs = fs.createReadStream('archive.tar');\n\nasync function run() {\n  await finished(rs);\n  console.log('Stream is done reading.');\n}\n\nrun().catch(console.error);\nrs.resume(); // Drain the stream.\n```\n\n`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                                    "properties": {
                                        "__promisify__": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "isErrored": {
                                    "description": "Returns whether the stream has encountered an error.",
                                    "type": "object"
                                },
                                "isReadable": {
                                    "description": "Returns whether the stream is readable.",
                                    "type": "object"
                                },
                                "pipeline": {
                                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nconst { pipeline } = require('stream');\nconst fs = require('fs');\nconst zlib = require('zlib');\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  }\n);\n```\n\nThe `pipeline` API provides a promise version, which can also\nreceive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with\nan`AbortError`.\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nTo use an `AbortSignal`, pass it inside an options object,\nas the last argument:\n\n```js\nconst { pipeline } = require('stream/promises');\n\nasync function run() {\n  const ac = new AbortController();\n  const signal = ac.signal;\n\n  setTimeout(() => ac.abort(), 1);\n  await pipeline(\n    fs.createReadStream('archive.tar'),\n    zlib.createGzip(),\n    fs.createWriteStream('archive.tar.gz'),\n    { signal },\n  );\n}\n\nrun().catch(console.error); // AbortError\n```\n\nThe `pipeline` API also supports async generators:\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    fs.createReadStream('lowercase.txt'),\n    async function* (source, signal) {\n      source.setEncoding('utf8');  // Work with strings rather than `Buffer`s.\n      for await (const chunk of source) {\n        yield await processChunk(chunk, { signal });\n      }\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\nRemember to handle the `signal` argument passed into the async generator.\nEspecially in the case where the async generator is the source for the\npipeline (i.e. first argument) or the pipeline will never complete.\n\n```js\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nasync function run() {\n  await pipeline(\n    async function * (signal) {\n      await someLongRunningfn({ signal });\n      yield 'asd';\n    },\n    fs.createWriteStream('uppercase.txt')\n  );\n  console.log('Pipeline succeeded.');\n}\n\nrun().catch(console.error);\n```\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors.",
                                    "properties": {
                                        "__promisify__": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "promises": {
                                    "properties": {
                                        "finished": {
                                            "type": "object"
                                        },
                                        "pipeline": {
                                            "type": "object"
                                        }
                                    },
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/GridFSBucketWriteStream"
                                }
                            },
                            "type": "object"
                        },
                        "HostAddress": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/HostAddress"
                                }
                            },
                            "type": "object"
                        },
                        "Int32": {
                            "description": "A class representation of a BSON Int32 type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Int32"
                                }
                            },
                            "type": "object"
                        },
                        "LEGAL_TCP_SOCKET_OPTIONS": {
                            "items": [
                                {
                                    "const": "family",
                                    "type": "string"
                                },
                                {
                                    "const": "hints",
                                    "type": "string"
                                },
                                {
                                    "const": "localAddress",
                                    "type": "string"
                                },
                                {
                                    "const": "localPort",
                                    "type": "string"
                                },
                                {
                                    "const": "lookup",
                                    "type": "string"
                                }
                            ],
                            "maxItems": 5,
                            "minItems": 5,
                            "type": "array"
                        },
                        "LEGAL_TLS_SOCKET_OPTIONS": {
                            "items": [
                                {
                                    "const": "ALPNProtocols",
                                    "type": "string"
                                },
                                {
                                    "const": "ca",
                                    "type": "string"
                                },
                                {
                                    "const": "cert",
                                    "type": "string"
                                },
                                {
                                    "const": "checkServerIdentity",
                                    "type": "string"
                                },
                                {
                                    "const": "ciphers",
                                    "type": "string"
                                },
                                {
                                    "const": "crl",
                                    "type": "string"
                                },
                                {
                                    "const": "ecdhCurve",
                                    "type": "string"
                                },
                                {
                                    "const": "key",
                                    "type": "string"
                                },
                                {
                                    "const": "minDHSize",
                                    "type": "string"
                                },
                                {
                                    "const": "passphrase",
                                    "type": "string"
                                },
                                {
                                    "const": "pfx",
                                    "type": "string"
                                },
                                {
                                    "const": "rejectUnauthorized",
                                    "type": "string"
                                },
                                {
                                    "const": "secureContext",
                                    "type": "string"
                                },
                                {
                                    "const": "secureProtocol",
                                    "type": "string"
                                },
                                {
                                    "const": "servername",
                                    "type": "string"
                                },
                                {
                                    "const": "session",
                                    "type": "string"
                                }
                            ],
                            "maxItems": 16,
                            "minItems": 16,
                            "type": "array"
                        },
                        "ListCollectionsCursor": {
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ListCollectionsCursor<any>"
                                }
                            },
                            "type": "object"
                        },
                        "ListIndexesCursor": {
                            "properties": {
                                "CLOSE": {
                                    "const": "close",
                                    "type": "string"
                                },
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ListIndexesCursor"
                                }
                            },
                            "type": "object"
                        },
                        "Logger": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Logger"
                                }
                            },
                            "type": "object"
                        },
                        "LoggerLevel": {
                            "properties": {
                                "DEBUG": {
                                    "const": "debug",
                                    "type": "string"
                                },
                                "ERROR": {
                                    "const": "error",
                                    "type": "string"
                                },
                                "INFO": {
                                    "const": "info",
                                    "type": "string"
                                },
                                "WARN": {
                                    "const": "warn",
                                    "type": "string"
                                },
                                "debug": {
                                    "const": "debug",
                                    "type": "string"
                                },
                                "error": {
                                    "const": "error",
                                    "type": "string"
                                },
                                "info": {
                                    "const": "info",
                                    "type": "string"
                                },
                                "warn": {
                                    "const": "warn",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Long": {
                            "description": "A class representing a 64-bit integer",
                            "properties": {
                                "MAX_UNSIGNED_VALUE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Maximum unsigned value."
                                },
                                "MAX_VALUE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Maximum signed value."
                                },
                                "MIN_VALUE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Minimum signed value."
                                },
                                "NEG_ONE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Signed negative one."
                                },
                                "ONE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Signed one."
                                },
                                "TWO_PWR_24": {
                                    "$ref": "#/definitions/Long"
                                },
                                "UONE": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Unsigned one."
                                },
                                "UZERO": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Unsigned zero."
                                },
                                "ZERO": {
                                    "$ref": "#/definitions/Long",
                                    "description": "Signed zero"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Long"
                                }
                            },
                            "type": "object"
                        },
                        "MONGO_CLIENT_EVENTS": {
                            "items": [
                                {
                                    "const": "connectionPoolCreated",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionPoolReady",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionPoolCleared",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionPoolClosed",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionCreated",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionReady",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionClosed",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionCheckOutStarted",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionCheckOutFailed",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionCheckedOut",
                                    "type": "string"
                                },
                                {
                                    "const": "connectionCheckedIn",
                                    "type": "string"
                                },
                                {
                                    "const": "commandStarted",
                                    "type": "string"
                                },
                                {
                                    "const": "commandSucceeded",
                                    "type": "string"
                                },
                                {
                                    "const": "commandFailed",
                                    "type": "string"
                                },
                                {
                                    "const": "serverOpening",
                                    "type": "string"
                                },
                                {
                                    "const": "serverClosed",
                                    "type": "string"
                                },
                                {
                                    "const": "serverDescriptionChanged",
                                    "type": "string"
                                },
                                {
                                    "const": "topologyOpening",
                                    "type": "string"
                                },
                                {
                                    "const": "topologyClosed",
                                    "type": "string"
                                },
                                {
                                    "const": "topologyDescriptionChanged",
                                    "type": "string"
                                },
                                {
                                    "const": "error",
                                    "type": "string"
                                },
                                {
                                    "const": "timeout",
                                    "type": "string"
                                },
                                {
                                    "const": "close",
                                    "type": "string"
                                },
                                {
                                    "const": "serverHeartbeatStarted",
                                    "type": "string"
                                },
                                {
                                    "const": "serverHeartbeatSucceeded",
                                    "type": "string"
                                },
                                {
                                    "const": "serverHeartbeatFailed",
                                    "type": "string"
                                }
                            ],
                            "maxItems": 26,
                            "minItems": 26,
                            "type": "array"
                        },
                        "Map": {
                            "$ref": "#/definitions/MapConstructor"
                        },
                        "MaxKey": {
                            "description": "A class representation of the BSON MaxKey type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/MaxKey"
                                }
                            },
                            "type": "object"
                        },
                        "MinKey": {
                            "description": "A class representation of the BSON MinKey type.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/MinKey"
                                }
                            },
                            "type": "object"
                        },
                        "MongoAPIError": {
                            "description": "An error generated when the driver API is used incorrectly",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoAPIError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoAWSError": {
                            "description": "A error generated when the user attempts to authenticate\nvia AWS, but fails",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoAWSError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoBatchReExecutionError": {
                            "description": "An error generated when a batch command is re-executed after one of the commands in the batch\nhas failed",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoBatchReExecutionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoBulkWriteError": {
                            "description": "An error indicating an unsuccessful Bulk Write",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoBulkWriteError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoChangeStreamError": {
                            "description": "An error generated when a ChangeStream operation fails to execute.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoChangeStreamError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoClient": {
                            "description": "The **MongoClient** class is a class that allows for making Connections to MongoDB.",
                            "properties": {
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoClient"
                                }
                            },
                            "type": "object"
                        },
                        "MongoCompatibilityError": {
                            "description": "An error generated when a feature that is not enabled or allowed for the current server\nconfiguration is used",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoCompatibilityError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoCredentials": {
                            "description": "A representation of the credentials used by MongoDB",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/MongoCredentials"
                                }
                            },
                            "type": "object"
                        },
                        "MongoCursorExhaustedError": {
                            "description": "An error thrown when an attempt is made to read from a cursor that has been exhausted",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoCursorExhaustedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoCursorInUseError": {
                            "description": "An error thrown when the user attempts to add options to a cursor that has already been\ninitialized",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoCursorInUseError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoDBNamespace": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/MongoDBNamespace"
                                }
                            },
                            "type": "object"
                        },
                        "MongoDecompressionError": {
                            "description": "An error generated when the driver fails to decompress\ndata received from the server.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoDecompressionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoDriverError": {
                            "description": "An error generated by the driver",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoDriverError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoError": {
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoErrorLabel": {
                            "properties": {
                                "HandshakeError": {
                                    "const": "HandshakeError",
                                    "type": "string"
                                },
                                "InterruptInUseConnections": {
                                    "const": "InterruptInUseConnections",
                                    "type": "string"
                                },
                                "NoWritesPerformed": {
                                    "const": "NoWritesPerformed",
                                    "type": "string"
                                },
                                "ResetPool": {
                                    "const": "ResetPool",
                                    "type": "string"
                                },
                                "ResumableChangeStreamError": {
                                    "const": "ResumableChangeStreamError",
                                    "type": "string"
                                },
                                "RetryableWriteError": {
                                    "const": "RetryableWriteError",
                                    "type": "string"
                                },
                                "TransientTransactionError": {
                                    "const": "TransientTransactionError",
                                    "type": "string"
                                },
                                "UnknownTransactionCommitResult": {
                                    "const": "UnknownTransactionCommitResult",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "MongoExpiredSessionError": {
                            "description": "An error generated when the user attempts to operate\non a session that has expired or has been closed.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoExpiredSessionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoGridFSChunkError": {
                            "description": "An error generated when a malformed or invalid chunk is\nencountered when reading from a GridFSStream.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoGridFSChunkError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoGridFSStreamError": {
                            "description": "An error generated when a GridFSStream operation fails to execute.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoGridFSStreamError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoInvalidArgumentError": {
                            "description": "An error generated when the user supplies malformed or unexpected arguments\nor when a required argument or field is not provided.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoInvalidArgumentError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoKerberosError": {
                            "description": "A error generated when the user attempts to authenticate\nvia Kerberos, but fails to connect to the Kerberos client.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoKerberosError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoMissingCredentialsError": {
                            "description": "An error generated when the user fails to provide authentication credentials before attempting\nto connect to a mongo server instance.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoMissingCredentialsError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoMissingDependencyError": {
                            "description": "An error generated when a required module or dependency is not present in the local environment",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoMissingDependencyError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoNetworkError": {
                            "description": "An error indicating an issue with the network, including TCP errors and timeouts.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoNetworkError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoNetworkTimeoutError": {
                            "description": "An error indicating a network timeout occurred",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoNetworkTimeoutError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoNotConnectedError": {
                            "description": "An error thrown when the user attempts to operate on a database or collection through a MongoClient\nthat has not yet successfully called the \"connect\" method",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoNotConnectedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoParseError": {
                            "description": "An error used when attempting to parse a value (like a connection string)",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoParseError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoRuntimeError": {
                            "description": "An error generated when the driver encounters unexpected input\nor reaches an unexpected/invalid internal state",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoRuntimeError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoServerClosedError": {
                            "description": "An error generated when an attempt is made to operate\non a closed/closing server.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoServerClosedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoServerError": {
                            "additionalProperties": {},
                            "description": "An error coming from the mongo server",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoServerError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoServerSelectionError": {
                            "description": "An error signifying a client-side server selection error",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoServerSelectionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoSystemError": {
                            "description": "An error signifying a general system issue",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoSystemError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoTailableCursorError": {
                            "description": "An error thrown when the user calls a function or method not supported on a tailable cursor",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoTailableCursorError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoTopologyClosedError": {
                            "description": "An error generated when an attempt is made to operate on a\ndropped, or otherwise unavailable, database.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoTopologyClosedError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoTransactionError": {
                            "description": "An error generated when the user makes a mistake in the usage of transactions.\n(e.g. attempting to commit a transaction with a readPreference other than primary)",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoTransactionError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoUnexpectedServerResponseError": {
                            "description": "An error generated when a **parsable** unexpected response comes from the server.\nThis is generally an error where the driver in a state expecting a certain behavior to occur in\nthe next message from MongoDB but it receives something else.\nThis error **does not** represent an issue with wire message formatting.\n\n#### Example\nWhen an operation fails, it is the driver's job to retry it. It must perform serverSelection\nagain to make sure that it attempts the operation against a server in a good state. If server\nselection returns a server that does not support retryable operations, this error is used.\nThis scenario is unlikely as retryable support would also have been determined on the first attempt\nbut it is possible the state change could report a selectable server that does not support retries.",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoUnexpectedServerResponseError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "MongoWriteConcernError": {
                            "description": "An error thrown when the server reports a writeConcernError",
                            "properties": {
                                "prepareStackTrace": {
                                    "description": "Optional override for formatting stack traces",
                                    "type": "object"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/MongoWriteConcernError"
                                },
                                "stackTraceLimit": {
                                    "type": "number"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectID": {
                            "description": "A class representation of the BSON ObjectId type.",
                            "properties": {
                                "cacheHexString": {
                                    "type": "boolean"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ObjectID"
                                }
                            },
                            "type": "object"
                        },
                        "ObjectId": {
                            "description": "A class representation of the BSON ObjectId type.",
                            "properties": {
                                "cacheHexString": {
                                    "type": "boolean"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ObjectID"
                                }
                            },
                            "type": "object"
                        },
                        "OrderedBulkOperation": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/OrderedBulkOperation"
                                }
                            },
                            "type": "object"
                        },
                        "ProfilingLevel": {
                            "properties": {
                                "all": {
                                    "const": "all",
                                    "type": "string"
                                },
                                "off": {
                                    "const": "off",
                                    "type": "string"
                                },
                                "slowOnly": {
                                    "const": "slow_only",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Promise": {
                            "description": "Global promise store allowing user-provided promises",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Promise"
                                }
                            },
                            "type": "object"
                        },
                        "ReadConcern": {
                            "description": "The MongoDB ReadConcern, which allows for control of the consistency and isolation properties\nof the data read from replica sets and replica set shards.",
                            "properties": {
                                "AVAILABLE": {
                                    "const": "available",
                                    "type": "string"
                                },
                                "LINEARIZABLE": {
                                    "const": "linearizable",
                                    "type": "string"
                                },
                                "MAJORITY": {
                                    "const": "majority",
                                    "type": "string"
                                },
                                "SNAPSHOT": {
                                    "const": "snapshot",
                                    "type": "string"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ReadConcern"
                                }
                            },
                            "type": "object"
                        },
                        "ReadConcernLevel": {
                            "properties": {
                                "available": {
                                    "const": "available",
                                    "type": "string"
                                },
                                "linearizable": {
                                    "const": "linearizable",
                                    "type": "string"
                                },
                                "local": {
                                    "const": "local",
                                    "type": "string"
                                },
                                "majority": {
                                    "const": "majority",
                                    "type": "string"
                                },
                                "snapshot": {
                                    "const": "snapshot",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "ReadPreference": {
                            "description": "The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\nused to construct connections.",
                            "properties": {
                                "NEAREST": {
                                    "const": "nearest",
                                    "type": "string"
                                },
                                "PRIMARY": {
                                    "const": "primary",
                                    "type": "string"
                                },
                                "PRIMARY_PREFERRED": {
                                    "const": "primaryPreferred",
                                    "type": "string"
                                },
                                "SECONDARY": {
                                    "const": "secondary",
                                    "type": "string"
                                },
                                "SECONDARY_PREFERRED": {
                                    "const": "secondaryPreferred",
                                    "type": "string"
                                },
                                "nearest": {
                                    "$ref": "#/definitions/ReadPreference"
                                },
                                "primary": {
                                    "$ref": "#/definitions/ReadPreference"
                                },
                                "primaryPreferred": {
                                    "$ref": "#/definitions/ReadPreference"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/ReadPreference"
                                },
                                "secondary": {
                                    "$ref": "#/definitions/ReadPreference"
                                },
                                "secondaryPreferred": {
                                    "$ref": "#/definitions/ReadPreference"
                                }
                            },
                            "type": "object"
                        },
                        "ReadPreferenceMode": {
                            "properties": {
                                "nearest": {
                                    "const": "nearest",
                                    "type": "string"
                                },
                                "primary": {
                                    "const": "primary",
                                    "type": "string"
                                },
                                "primaryPreferred": {
                                    "const": "primaryPreferred",
                                    "type": "string"
                                },
                                "secondary": {
                                    "const": "secondary",
                                    "type": "string"
                                },
                                "secondaryPreferred": {
                                    "const": "secondaryPreferred",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "ReturnDocument": {
                            "properties": {
                                "AFTER": {
                                    "const": "after",
                                    "type": "string"
                                },
                                "BEFORE": {
                                    "const": "before",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "ServerApiVersion": {
                            "properties": {
                                "v1": {
                                    "const": "1",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "ServerCapabilities": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerCapabilities"
                                }
                            },
                            "type": "object"
                        },
                        "ServerClosedEvent": {
                            "description": "Emitted when server is closed.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerClosedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerDescription": {
                            "description": "The client's view of a single server, based on the most recent hello outcome.\n\nInternal type, not meant to be directly instantiated",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerDescription"
                                }
                            },
                            "type": "object"
                        },
                        "ServerDescriptionChangedEvent": {
                            "description": "Emitted when server description changes, but does NOT include changes to the RTT.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerDescriptionChangedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerHeartbeatFailedEvent": {
                            "description": "Emitted when the server monitors hello fails, either with an ok: 0 or a socket exception.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerHeartbeatFailedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerHeartbeatStartedEvent": {
                            "description": "Emitted when the server monitors hello command is started - immediately before\nthe hello command is serialized into raw BSON and written to the socket.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerHeartbeatStartedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerHeartbeatSucceededEvent": {
                            "description": "Emitted when the server monitors hello succeeds.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerHeartbeatSucceededEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerOpeningEvent": {
                            "description": "Emitted when server is initialized.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerOpeningEvent"
                                }
                            },
                            "type": "object"
                        },
                        "ServerSession": {
                            "description": "Reflects the existence of a session on the server. Can be reused by the session pool.\nWARNING: not meant to be instantiated directly. For internal use only.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/ServerSession"
                                }
                            },
                            "type": "object"
                        },
                        "ServerType": {
                            "description": "An enumeration of server types we know about",
                            "properties": {
                                "LoadBalancer": {
                                    "const": "LoadBalancer",
                                    "type": "string"
                                },
                                "Mongos": {
                                    "const": "Mongos",
                                    "type": "string"
                                },
                                "PossiblePrimary": {
                                    "const": "PossiblePrimary",
                                    "type": "string"
                                },
                                "RSArbiter": {
                                    "const": "RSArbiter",
                                    "type": "string"
                                },
                                "RSGhost": {
                                    "const": "RSGhost",
                                    "type": "string"
                                },
                                "RSOther": {
                                    "const": "RSOther",
                                    "type": "string"
                                },
                                "RSPrimary": {
                                    "const": "RSPrimary",
                                    "type": "string"
                                },
                                "RSSecondary": {
                                    "const": "RSSecondary",
                                    "type": "string"
                                },
                                "Standalone": {
                                    "const": "Standalone",
                                    "type": "string"
                                },
                                "Unknown": {
                                    "const": "Unknown",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "StreamDescription": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/StreamDescription"
                                }
                            },
                            "type": "object"
                        },
                        "Timestamp": {
                            "properties": {
                                "MAX_VALUE": {
                                    "$ref": "#/definitions/Long"
                                },
                                "prototype": {
                                    "$ref": "#/definitions/Timestamp"
                                }
                            },
                            "type": "object"
                        },
                        "TopologyClosedEvent": {
                            "description": "Emitted when topology is closed.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/TopologyClosedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "TopologyDescription": {
                            "description": "Representation of a deployment of servers",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/TopologyDescription"
                                }
                            },
                            "type": "object"
                        },
                        "TopologyDescriptionChangedEvent": {
                            "description": "Emitted when topology description changes.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/TopologyDescriptionChangedEvent"
                                }
                            },
                            "type": "object"
                        },
                        "TopologyOpeningEvent": {
                            "description": "Emitted when topology is initialized.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/TopologyOpeningEvent"
                                }
                            },
                            "type": "object"
                        },
                        "TopologyType": {
                            "description": "An enumeration of topology types we know about",
                            "properties": {
                                "LoadBalanced": {
                                    "const": "LoadBalanced",
                                    "type": "string"
                                },
                                "ReplicaSetNoPrimary": {
                                    "const": "ReplicaSetNoPrimary",
                                    "type": "string"
                                },
                                "ReplicaSetWithPrimary": {
                                    "const": "ReplicaSetWithPrimary",
                                    "type": "string"
                                },
                                "Sharded": {
                                    "const": "Sharded",
                                    "type": "string"
                                },
                                "Single": {
                                    "const": "Single",
                                    "type": "string"
                                },
                                "Unknown": {
                                    "const": "Unknown",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "Transaction": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/Transaction"
                                }
                            },
                            "type": "object"
                        },
                        "TypedEventEmitter": {
                            "description": "Typescript type safe event emitter",
                            "properties": {
                                "EventEmitter": {
                                    "$ref": "#/definitions/typeofimport(\"events\")",
                                    "description": "The `EventEmitter` class is defined and exposed by the `events` module:\n\n```js\nconst EventEmitter = require('events');\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                                },
                                "EventEmitterAsyncResource": {
                                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that require\nmanual async tracking. Specifically, all events emitted by instances of\n`EventEmitterAsyncResource` will run within its async context.\n\nThe EventEmitterAsyncResource class has the same methods and takes the\nsame options as EventEmitter and AsyncResource themselves."
                                },
                                "captureRejectionSymbol": {
                                    "$ref": "#/definitions/typeofcaptureRejectionSymbol"
                                },
                                "captureRejections": {
                                    "description": "Sets or gets the default captureRejection value for all emitters.",
                                    "type": "boolean"
                                },
                                "defaultMaxListeners": {
                                    "type": "number"
                                },
                                "errorMonitor": {
                                    "$ref": "#/definitions/typeoferrorMonitor",
                                    "description": "This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed."
                                },
                                "prototype": {
                                    "$ref": "#/definitions/TypedEventEmitter<any>"
                                }
                            },
                            "type": "object"
                        },
                        "UnorderedBulkOperation": {
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/UnorderedBulkOperation"
                                }
                            },
                            "type": "object"
                        },
                        "WriteConcern": {
                            "description": "A MongoDB WriteConcern, which describes the level of acknowledgement\nrequested from MongoDB for write operations.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/WriteConcern"
                                }
                            },
                            "type": "object"
                        },
                        "WriteConcernError": {
                            "description": "An error representing a failure by the server to apply the requested write concern to the bulk operation.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/WriteConcernError"
                                }
                            },
                            "type": "object"
                        },
                        "WriteError": {
                            "description": "An error that occurred during a BulkWrite on the server.",
                            "properties": {
                                "prototype": {
                                    "$ref": "#/definitions/WriteError"
                                }
                            },
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "mquery": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/mquery"
                        }
                    },
                    "type": "object"
                },
                "now": {
                    "description": "Mongoose uses this function to get the current time when setting\n[timestamps](/docs/guide.html#timestamps). You may stub out this function\nusing a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.",
                    "type": "object"
                },
                "plugin": {
                    "description": "Declares a global plugin executed on all Schemas.",
                    "type": "object"
                },
                "pluralize": {
                    "description": "Getter/setter around function for pluralizing collection names.",
                    "type": "object"
                },
                "sanitizeFilter": {
                    "description": "Sanitizes query filters against query selector injection attacks by wrapping\nany nested objects that have a property whose name starts with `$` in a `$eq`.",
                    "type": "object"
                },
                "set": {
                    "description": "Sets mongoose options",
                    "type": "object"
                },
                "setDriver": {
                    "description": "Overwrites the current driver used by this Mongoose instance. A driver is a\nMongoose-specific interface that defines functions like `find()`.",
                    "type": "object"
                },
                "startSession": {
                    "description": "_Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\nfor benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\nand [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).",
                    "type": "object"
                },
                "syncIndexes": {
                    "description": "Makes the indexes in MongoDB match the indexes defined in every model's\nschema. This function will drop any indexes that are not defined in\nthe model's schema except the `_id` index, and build any indexes that\nare in your schema but not in MongoDB.",
                    "type": "object"
                },
                "trusted": {
                    "description": "Tells `sanitizeFilter()` to skip the given object when filtering out potential query selector injection attacks.\nUse this method when you have a known query selector that you want to use.",
                    "type": "object"
                },
                "version": {
                    "description": "The Mongoose version",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "{[path:string]:SchemaDefinitionProperty<undefined>;}": {
            "additionalProperties": {
                "$ref": "#/definitions/SchemaDefinitionProperty<undefined>"
            },
            "type": "object"
        },
        "{[x:string]:SchemaDefinitionProperty<any>|undefined;}": {
            "type": "object"
        },
        "{[x:string]:any;}": {
            "type": "object"
        },
        "{[x:string]:any;}_1": {
            "type": "object"
        },
        "{[x:string]:any;}_2": {
            "type": "object"
        },
        "{[x:string]:any;}_3": {
            "type": "object"
        },
        "{}": {
            "type": "object"
        },
        "{}_2": {
            "type": "object"
        },
        "{}_3": {
            "type": "object"
        },
        "{}_4": {
            "type": "object"
        },
        "{}_5": {
            "type": "object"
        }
    },
    "properties": {
        "$locals": {
            "$ref": "#/definitions/Record<string,unknown>",
            "description": "Empty object that you can use for storing properties on the document. This\nis handy for passing data to middleware without conflicting with Mongoose\ninternals."
        },
        "$op": {
            "anyOf": [
                {
                    "enum": [
                        "remove",
                        "save",
                        "validate"
                    ],
                    "type": "string"
                },
                {
                    "type": "null"
                }
            ],
            "description": "A string containing the current operation that Mongoose is executing\non this document. Can be `null`, `'save'`, `'validate'`, or `'remove'`."
        },
        "$where": {
            "$ref": "#/definitions/Record<string,unknown>",
            "description": "Set this property to add additional query filters when Mongoose saves this document and `isNew` is false."
        },
        "__v": {
            "description": "This documents __v."
        },
        "_id": {
            "description": "This documents _id."
        },
        "banner": {
            "type": "string"
        },
        "baseModelName": {
            "description": "If this is a discriminator model, `baseModelName` is the name of the base model.",
            "type": "string"
        },
        "collection": {
            "$ref": "#/definitions/Collection<Document>",
            "description": "Collection the model uses."
        },
        "createdAt": {
            "format": "date-time",
            "type": "string"
        },
        "db": {
            "$ref": "#/definitions/Connection",
            "description": "Connection the model uses."
        },
        "description": {
            "type": "string"
        },
        "errors": {
            "$ref": "#/definitions/Error.ValidationError",
            "description": "Returns the current validation errors."
        },
        "id": {
            "description": "The string version of this documents _id."
        },
        "isNew": {
            "description": "Boolean flag specifying if the document is new.",
            "type": "boolean"
        },
        "name": {
            "type": "string"
        },
        "schema": {
            "$ref": "#/definitions/Schema<any,Model<any,any,any,any,any>,{},{},{},{},DefaultSchemaOptions,{[x:string]:any;}>",
            "description": "The document's schema."
        },
        "slug": {
            "type": "string"
        },
        "updatedAt": {
            "format": "date-time",
            "type": "string"
        }
    },
    "type": "object"
}

